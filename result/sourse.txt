
package org.opengis.coverage;
import org.opengis.spatialschema.geometry.DirectPosition;
  public class CannotEvaluateException extends RuntimeException {
       private static final long serialVersionUID = 506793649975583062L;
       public CannotEvaluateException() {
        super();
    }
       public CannotEvaluateException(String message) {
        super(message);
    }
}
package org.opengis.coverage;
import java.util.List;
import java.util.ArrayList;
import org.opengis.util.CodeList;
public final class ColorInterpretation extends CodeList {
       private static final long serialVersionUID = 6947933527594223350L;
       private static final List VALUES = new ArrayList(14);
       public static final ColorInterpretation UNDEFINED = new ColorInterpretation("UNDEFINED");
       public static final ColorInterpretation GRAY_INDEX = new ColorInterpretation("GRAY_INDEX");
       public static final ColorInterpretation PALETTE_INDEX = new ColorInterpretation("PALETTE_INDEX");
       public static final ColorInterpretation RED_BAND = new ColorInterpretation("RED_BAND");
       public static final ColorInterpretation GREEN_BAND = new ColorInterpretation("GREEN_BAND");
       public static final ColorInterpretation BLUE_BAND = new ColorInterpretation("BLUE_BAND");
       public static final ColorInterpretation ALPHA_BAND = new ColorInterpretation("ALPHA_BAND");
       public static final ColorInterpretation HUE_BAND = new ColorInterpretation("HUE_BAND");
       public static final ColorInterpretation SATURATION_BAND = new ColorInterpretation("SATURATION_BAND");
       public static final ColorInterpretation LIGHTNESS_BAND = new ColorInterpretation("LIGHTNESS_BAND");
       public static final ColorInterpretation CYAN_BAND = new ColorInterpretation("CYAN_BAND");
       public static final ColorInterpretation MAGENTA_BAND = new ColorInterpretation("MAGENTA_BAND");
       public static final ColorInterpretation YELLOW_BAND = new ColorInterpretation("YELLOW_BAND");
       public static final ColorInterpretation BLACK_BAND = new ColorInterpretation("BLACK_BAND");
       public ColorInterpretation(final String name) {
        super(name, VALUES);
    }
       public static ColorInterpretation[] values() {
        synchronized (VALUES) {
            return (ColorInterpretation[]) VALUES.toArray(new ColorInterpretation[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.coverage;
import java.awt.image.Raster;
                     import java.awt.image.renderable.RenderableImage;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.Envelope;
public interface Coverage {
       CoordinateReferenceSystem getCoordinateReferenceSystem();
       Envelope getEnvelope();
       String[] getDimensionNames();
       int getNumSampleDimensions();
       SampleDimension getSampleDimension(int index) throws IndexOutOfBoundsException;
       int getNumSources();
       Coverage getSource(int sourceDataIndex) throws IndexOutOfBoundsException;
       String[] getMetadataNames();
       String getMetadataValue(String name) throws MetadataNameNotFoundException;
       Object evaluate(DirectPosition point) throws CannotEvaluateException;
       boolean[] evaluate(DirectPosition point, boolean[] destination)            throws CannotEvaluateException, ArrayIndexOutOfBoundsException;
       byte[] evaluate(DirectPosition point, byte[] destination)            throws CannotEvaluateException, ArrayIndexOutOfBoundsException;
       int[] evaluate(DirectPosition point, int[] destination)            throws CannotEvaluateException, ArrayIndexOutOfBoundsException;
       double[] evaluate(DirectPosition point, float[] destination)            throws CannotEvaluateException, ArrayIndexOutOfBoundsException;
       double[] evaluate(DirectPosition point, double[] destination)            throws CannotEvaluateException, ArrayIndexOutOfBoundsException;
           RenderableImage getRenderableImage(int xAxis, int yAxis)            throws UnsupportedOperationException, IndexOutOfBoundsException;
}
package org.opengis.coverage.grid;
import java.util.List;
import java.util.ArrayList;
import org.opengis.util.CodeList;
public final class ByteInValuePacking extends CodeList {
       private static final long serialVersionUID = -5830149616089633137L;
       private static final List VALUES = new ArrayList(2);
       public static final ByteInValuePacking WKB_XDR = new ByteInValuePacking("WKB_XDR");
       public static final ByteInValuePacking WKB_NDR = new ByteInValuePacking("WKB_NDR");
       public ByteInValuePacking(final String name) {
        super(name, VALUES);
    }
       public static ByteInValuePacking[] values() {
        synchronized (VALUES) {
            return (ByteInValuePacking[]) VALUES.toArray(new ByteInValuePacking[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.coverage.grid;
import java.io.IOException;
public class CannotCreateGridCoverageException extends IOException {
       private static final long serialVersionUID = 3768704221879769389L;
       public CannotCreateGridCoverageException() {
        super();
    }
       public CannotCreateGridCoverageException(String message) {
        super(message);
    }
}
package org.opengis.coverage.grid;
import java.awt.image.Raster;
              import java.awt.image.WritableRaster;
      import java.awt.image.RenderedImage;
       import org.opengis.coverage.Coverage;
public interface GridCoverage extends Coverage {
       boolean isDataEditable();
       GridPacking getGridPacking();
       GridGeometry getGridGeometry();
       int[] getOptimalDataBlockSizes();
       int getNumOverviews();
       GridGeometry getOverviewGridGeometry(int overviewIndex) throws IndexOutOfBoundsException;
       GridCoverage getOverview(int overviewIndex) throws IndexOutOfBoundsException;
          boolean[] getDataBlock(GridRange gridRange, boolean[] destination)            throws InvalidRangeException, ArrayIndexOutOfBoundsException;
       byte[] getDataBlock(GridRange gridRange, byte[] destination)            throws InvalidRangeException, ArrayIndexOutOfBoundsException;
       short[] getDataBlock(GridRange gridRange, short[] destination)            throws InvalidRangeException, ArrayIndexOutOfBoundsException;
       int[] getDataBlock(GridRange gridRange, int[] destination)            throws InvalidRangeException, ArrayIndexOutOfBoundsException;
       float[] getDataBlock(GridRange gridRange, float[] destination)            throws InvalidRangeException, ArrayIndexOutOfBoundsException;
       double[] getDataBlock(GridRange gridRange, double[] destination)            throws InvalidRangeException, ArrayIndexOutOfBoundsException;
       byte[] getPackedDataBlock(GridRange gridRange) throws InvalidRangeException;
       void setDataBlock(GridRange gridRange, boolean[] values)            throws InvalidRangeException, GridNotEditableException, ArrayIndexOutOfBoundsException;
       void setDataBlock(GridRange gridRange, byte[] values)            throws InvalidRangeException, GridNotEditableException, ArrayIndexOutOfBoundsException;
       void setDataBlock(GridRange gridRange, short[] values)            throws InvalidRangeException, GridNotEditableException, ArrayIndexOutOfBoundsException;
       void setDataBlock(GridRange gridRange, int[] values)            throws InvalidRangeException, GridNotEditableException, ArrayIndexOutOfBoundsException;
       void setDataBlock(GridRange gridRange, float[] values)            throws InvalidRangeException, GridNotEditableException, ArrayIndexOutOfBoundsException;
       void setDataBlock(GridRange gridRange, double[] values)            throws InvalidRangeException, GridNotEditableException, ArrayIndexOutOfBoundsException;
       void setPackedDataBlock(GridRange gridRange, byte[] values)            throws InvalidRangeException, GridNotEditableException, ArrayIndexOutOfBoundsException;
}
package org.opengis.coverage.grid;
import org.opengis.referencing.operation.MathTransform;
public interface GridGeometry {
       GridRange getGridRange();
       MathTransform getGridToCoordinateSystem();
}
package org.opengis.coverage.grid;
public class GridNotEditableException extends IllegalStateException {
       private static final long serialVersionUID = 612186655921122650L;
       public GridNotEditableException() {
        super();
    }
       public GridNotEditableException(String message) {
        super(message);
    }
}
package org.opengis.coverage.grid;
import org.opengis.coverage.SampleDimensionType;
  public interface GridPacking {
       ByteInValuePacking getByteInValuePacking();
       ValueInBytePacking getValueInBytePacking();
       int getBandPacking();
}
package org.opengis.coverage.grid;
public interface GridRange {
       int[] getLower();
       int[] getUpper();
}
package org.opengis.coverage.grid;
public class InvalidRangeException extends IllegalArgumentException {
       private static final long serialVersionUID = 3165512862939920847L;
       public InvalidRangeException() {
        super();
    }
       public InvalidRangeException(String message) {
        super(message);
    }
}
package org.opengis.coverage.grid;
import java.util.List;
import java.util.ArrayList;
import org.opengis.util.CodeList;
import org.opengis.coverage.SampleDimensionType;
  public final class ValueInBytePacking extends CodeList {
       private static final long serialVersionUID = 6895036289489868770L;
       private static final List VALUES = new ArrayList(2);
       public static final ValueInBytePacking LO_BIT_FIRST = new ValueInBytePacking("LO_BIT_FIRST");
       public static final ValueInBytePacking HI_BIT_FIRST = new ValueInBytePacking("HI_BIT_FIRST");
       public ValueInBytePacking(final String name) {
        super(name, VALUES);
    }
       public static ValueInBytePacking[] values() {
        synchronized (VALUES) {
            return (ValueInBytePacking[]) VALUES.toArray(new ValueInBytePacking[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.coverage;
public class MetadataNameNotFoundException extends IllegalArgumentException {
       private static final long serialVersionUID = 3217010469714161299L;
       public MetadataNameNotFoundException() {
        super();
    }
       public MetadataNameNotFoundException(String message) {
        super(message);
    }
}
package org.opengis.coverage;
import java.util.List;
import java.util.ArrayList;
import java.awt.color.ColorSpace;
 import org.opengis.util.CodeList;
public final class PaletteInterpretation extends CodeList {
       private static final long serialVersionUID = -7387623392932592485L;
       private static final List VALUES = new ArrayList(4);
       public static final PaletteInterpretation GRAY = new PaletteInterpretation("GRAY");
       public static final PaletteInterpretation RGB = new PaletteInterpretation("RGB");
       public static final PaletteInterpretation CMYK = new PaletteInterpretation("CMYK");
       public static final PaletteInterpretation HLS = new PaletteInterpretation("HLS");
       public PaletteInterpretation(final String name) {
        super(name, VALUES);
    }
       public static PaletteInterpretation[] values() {
        synchronized (VALUES) {
            return (PaletteInterpretation[]) VALUES.toArray(new PaletteInterpretation[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.coverage;
import org.opengis.spatialschema.geometry.DirectPosition;
  public class PointOutsideCoverageException extends CannotEvaluateException {
       private static final long serialVersionUID = -8718412090539227101L;
           public PointOutsideCoverageException() {
        super();
    }
           public PointOutsideCoverageException(String message) {
        super(message);
    }
}
package org.opengis.coverage.processing;
import org.opengis.coverage.grid.GridCoverage;
import org.opengis.coverage.SampleDimensionType;
 import org.opengis.coverage.MetadataNameNotFoundException;
import org.opengis.parameter.GeneralParameterValue;
import org.opengis.parameter.ParameterNotFoundException;
import org.opengis.parameter.InvalidParameterNameException;
import org.opengis.parameter.InvalidParameterValueException;
public interface GridCoverageProcessor {
       String[] getMetadataNames();
       String getMetadataValue(String name) throws MetadataNameNotFoundException;
       int getNumOperations();
       Operation getOperation(int index) throws IndexOutOfBoundsException;
       GridAnalysis analyse(GridCoverage gridCoverage);
       GridCoverage doOperation(String operationName, GeneralParameterValue[] parameters)            throws OperationNotFoundException, ParameterNotFoundException,                   InvalidParameterNameException, InvalidParameterValueException;
}
package org.opengis.coverage.processing;
public class InvalidSampleDimensionException extends IllegalArgumentException {
       private static final long serialVersionUID = -7526979322493497443L;
       public InvalidSampleDimensionException() {
        super();
    }
       public InvalidSampleDimensionException(String message) {
        super(message);
    }
}
package org.opengis.coverage.processing;
import org.opengis.parameter.GeneralOperationParameter;
public interface Operation {
       String getName();
       String getDescription();
       String getVendor();
       String getDocURL();
       String getVersion();
       int getNumSources();
       GeneralOperationParameter[] getParameters();
}
package org.opengis.coverage.processing;
public class OperationNotFoundException extends IllegalArgumentException {
       private static final long serialVersionUID = 8654574655958181935L;
       public OperationNotFoundException() {
        super();
    }
       public OperationNotFoundException(String message) {
        super(message);
    }
}
package org.opengis.coverage;
import javax.units.Unit;
import org.opengis.referencing.operation.MathTransform1D;
public interface SampleDimension {
       String getDescription();
       SampleDimensionType getSampleDimensionType();
       String[] getCategoryNames();
       ColorInterpretation getColorInterpretation();
       PaletteInterpretation getPaletteInterpretation();
       int[][] getPalette();
       double[] getNoDataValues();
       double getMinimumValue();
       double getMaximumValue();
       Unit getUnits();
       double getOffset();
       double getScale();
       MathTransform1D getSampleToGeophysics();
       String[] getMetaDataNames();
       String getMetadataValue(String name) throws MetadataNameNotFoundException;
}
package org.opengis.coverage;
import java.util.List;
import java.util.ArrayList;
import java.awt.image.DataBuffer;
 import org.opengis.util.CodeList;
public final class SampleDimensionType extends CodeList {
       private static final long serialVersionUID = -4153433145134818506L;
       private static final List VALUES = new ArrayList(11);
       public static final SampleDimensionType UNSIGNED_1BIT = new SampleDimensionType("UNSIGNED_1BIT");
       public static final SampleDimensionType UNSIGNED_2BITS = new SampleDimensionType("UNSIGNED_2BITS");
       public static final SampleDimensionType UNSIGNED_4BITS = new SampleDimensionType("UNSIGNED_4BITS");
       public static final SampleDimensionType UNSIGNED_8BITS = new SampleDimensionType("UNSIGNED_8BITS");
       public static final SampleDimensionType SIGNED_8BITS = new SampleDimensionType("SIGNED_8BITS");
       public static final SampleDimensionType UNSIGNED_16BITS = new SampleDimensionType("UNSIGNED_16BITS");
       public static final SampleDimensionType SIGNED_16BITS = new SampleDimensionType("SIGNED_16BITS");
       public static final SampleDimensionType UNSIGNED_32BITS = new SampleDimensionType("UNSIGNED_32BITS");
       public static final SampleDimensionType SIGNED_32BITS = new SampleDimensionType("SIGNED_32BITS");
       public static final SampleDimensionType REAL_32BITS = new SampleDimensionType("REAL_32BITS");
       public static final SampleDimensionType REAL_64BITS = new SampleDimensionType("REAL_64BITS");
       public SampleDimensionType(final String name) {
        super(name, VALUES);
    }
       public static SampleDimensionType[] values() {
        synchronized (VALUES) {
            return (SampleDimensionType[]) VALUES.toArray(new SampleDimensionType[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.go.spatial.PathType;
public interface CommonCapabilities {
       Class[] getSupportedBounds();
       Class[] getSupportedDirectPositions();
       Class[] getSupportedDirectPositions(CoordinateReferenceSystem crs);
       Class[] getSupportedSpatialSchemaObjects(CoordinateReferenceSystem crs);
       Class[] getSupportedOrientations();
       Class[] getSupportedOrientations(CoordinateReferenceSystem crs);
       Class[] getSupportedGeometries();
       String[] getSupportedCoordinateReferenceSystems();
       String[] getSupportedDatums();
       PathType[] getSupportedPathTypes();
       String[] getSupportedProjections();
}
package org.opengis.go;
import org.opengis.referencing.crs.CRSAuthorityFactory;
import org.opengis.referencing.crs.CRSFactory;
import org.opengis.referencing.datum.DatumAuthorityFactory;
import org.opengis.referencing.datum.DatumFactory;
import org.opengis.go.geometry.BoundsFactory;
public interface CommonFactory {
       public CommonCapabilities getCapabilities();
              public BoundsFactory getBoundsFactory();
       public CRSFactory getCRSFactory();
           public CRSAuthorityFactory getCRSAuthorityFactory();
              public DatumAuthorityFactory getDatumAuthorityFactory();
           public DatumFactory getDatumFactory();
}
package org.opengis.go.display.canvas;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.IncompatibleOperationException;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.go.display.DisplayFactory;
import org.opengis.go.display.event.EventManager;
import org.opengis.go.display.primitive.Graphic;
import org.opengis.go.geometry.BoundingRectangle;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface Canvas {
           void dispose();
       void disposeEventManagers();
           String getUID();
       void setTitle(String title);
       String getTitle();
       DisplayFactory getFactory();
       CanvasState getState();
       boolean isVisible(DirectPosition coordinate);
           Graphic add(Graphic graphic);
       Graphic addAsEditable(Graphic graphic);
       void remove(Graphic graphic);
       EventManager findEventManager(Class eventManagerClass);
       void addEventManager(EventManager eventManager);
       Graphic getTopGraphicAt(DirectPosition directPosition);
       Graphic[] getGraphicsAt(DirectPosition directPosition);
       Graphic[] getGraphicsIn(BoundingRectangle bounds);
           void addCanvasListener(CanvasListener listener);
       void removeCanvasListener(CanvasListener listener);
           void enableCanvasHandler(CanvasHandler handler);
       void removeCanvasHandler(CanvasHandler handler);
       CanvasHandler getActiveCanvasHandler();
           void setImplHint(String hintName, Object hint);
       Object getImplHint(String hintName);
           CoordinateReferenceSystem getDisplayCoordinateReferenceSystem();
       CoordinateReferenceSystem getObjectiveCoordinateReferenceSystem();
       void setObjectiveCoordinateReferenceSystem(CoordinateReferenceSystem crs);
           void setObjectiveCoordinateReferenceSystem(CoordinateReferenceSystem crs, MathTransform objectiveToDisplay,                                 MathTransform displayToObjective) throws IncompatibleOperationException;
       MathTransform getObjectiveToDisplayTransform();
           MathTransform getDisplayToObjectiveTransform();
}
package org.opengis.go.display.canvas;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface CanvasController {
       public void setCenter(DirectPosition newCenter);
    }
package org.opengis.go.display.canvas;
public interface CanvasHandler {
       public void handlerEnabled(CanvasController controller);
       public void handlerRemoved();
}
package org.opengis.go.display.canvas;
public interface CanvasListener {
       public void canvasChanged(Canvas canvas, CanvasState newState);
}
package org.opengis.go.display.canvas;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface CanvasState {
       public String getTitle();
       public DirectPosition getCenter();
       public Object clone() throws CloneNotSupportedException;
       public boolean equals(Object object);
    }
package org.opengis.go.display;
import org.opengis.go.display.style.ArrowStyle;
import org.opengis.go.display.style.FillPattern;
import org.opengis.go.display.style.FillStyle;
import org.opengis.go.display.style.GraphicStyle;
import org.opengis.go.display.style.LineCap;
import org.opengis.go.display.style.LineJoin;
import org.opengis.go.display.style.LinePattern;
import org.opengis.go.display.style.LineStyle;
import org.opengis.go.display.style.Mark;
import org.opengis.go.display.style.SymbologyInfo;
import org.opengis.go.display.style.XAnchor;
import org.opengis.go.display.style.YAnchor;
public interface DisplayCapabilities {
           public Class[] getSupportedPrimitives();
           public boolean isEventManagerSupported(Class eventManagerClass);
           public boolean isBacklightingSupported();
           public boolean isLineWidthSupported();
           public boolean isLineGapSupported();
           public ArrowStyle[] getSupportedArrowStyles();
           public LineStyle[] getSupportedLineStyles();
           public LineJoin[] getSupportedLineJoins();
           public LineCap[] getSupportedLineCaps();
           public boolean isDashPatternSupported();
           public boolean isBlinkSupported();
           public FillStyle[] getSupportedFillStyles();
           public FillPattern[] getSupportedFillPatterns();
           public Mark[] getSupportedMarks();
           public LinePattern[] getSupportedLinePatterns();
           public XAnchor[] getSupportedXAnchors();
           public YAnchor[] getSupportedYAnchors();
           public boolean isGradientSupported();
           public GraphicStyle getDefaultGraphicStyle();
           public SymbologyInfo[] getSupportedSymbologies();
     }
package org.opengis.go.display;
import java.awt.Container;
import java.util.Properties;
import org.opengis.go.display.canvas.Canvas;
import org.opengis.go.display.primitive.Graphic;
public interface DisplayFactory {
       public Graphic createGraphic(Class implementsGraphic);
       public DisplayCapabilities getCapabilities();
           public Canvas createCanvas(Properties canvasProperties, Container container);
           public Canvas createCanvas(Properties canvasProperties);
           public Canvas getCanvas(String uid);
}
package org.opengis.go.display.event;
public interface AggregationChangeEvent {
       public static final int ELEMENT_ADDED = 0;
       public static final int ELEMENT_REMOVED = 1;
       public static final int ELEMENTS_REORDERD = 2;
       public int getID();
}
package org.opengis.go.display.event;
import java.util.EventListener;
public interface AggregationListener extends EventListener {
                   public void aggregationChanged(AggregationChangeEvent event);
}
package org.opengis.go.display.event;
import java.util.EventListener;
public interface EventHandler extends EventListener {
       public abstract void handlerEnabled();
       public abstract void handlerDisabled();
       public abstract void handlerRemoved();
}
package org.opengis.go.display.event;
public interface EventManager {
}
package org.opengis.go.display.event;
public interface GraphicChangeEvent extends GraphicEvent {
           public static final int EDITABLE_CHANGED = 0;
           public static final int EDITABLE_END = 1;
           public static final int EDITABLE_START = 2;
           public static final int GRAPHIC_CHANGED = 3;
               public static final int GRAPHIC_DESELECTED = 4;
               public static final int GRAPHIC_DISPOSED = 5;
               public static final int GRAPHIC_SELECTED = 6;
                   public int getID();
        }
package org.opengis.go.display.event;
import org.opengis.go.display.primitive.Graphic;
public interface GraphicEvent {
                   public Graphic getGraphic();
       public void consume();
       public boolean isConsumed();
}
package org.opengis.go.display.event;
import java.awt.event.KeyEvent;
public interface GraphicKeyEvent extends GraphicEvent {
       public KeyEvent getKeyEvent();
}
package org.opengis.go.display.event;
import java.util.EventListener;
public interface GraphicListener extends EventListener {
       public void mouseClicked(GraphicMouseEvent ge);
       public void mousePressed(GraphicMouseEvent ge);
       public void mouseReleased(GraphicMouseEvent ge);
       public void mouseDwelled(GraphicMouseEvent ge);
       public void graphicSelected(GraphicChangeEvent ge);
       public void graphicDeselected(GraphicChangeEvent ge);
       public void graphicDisposed(GraphicChangeEvent ge);
       public void graphicEditableStart(GraphicChangeEvent ge);
       public void graphicEditableChanged(GraphicChangeEvent ge);
       public void graphicEditableEnd(GraphicChangeEvent ge);
       public void graphicChanged(GraphicChangeEvent ge);
}
package org.opengis.go.display.event;
import java.awt.event.MouseEvent;
public interface GraphicMouseEvent extends GraphicEvent {
           public static final int MOUSE_CLICKED = 0;
               public static final int MOUSE_DWELLED = 1;
               public static final int MOUSE_PRESSED = 2;
               public static final int MOUSE_RELEASED = 3;
           public int getID();
                   public MouseEvent getMouseEvent();
        }
package org.opengis.go.display.event;
import java.awt.event.KeyListener;
public interface KeyHandler extends EventHandler, KeyListener {
}
package org.opengis.go.display.event;
public interface KeyManager extends EventManager {
       public void enableKeyHandler(KeyHandler keyHandler);
       public void pushKeyHandler(KeyHandler keyHandler);
       public void removeKeyHandler(KeyHandler keyHandler);
       public boolean replaceKeyHandler(KeyHandler existingHandler,                                     KeyHandler replacementHandler);
       public KeyHandler getCurrentKeyHandler();
       public KeyHandler[] getFallbackKeyHandlers();
}
package org.opengis.go.display.event;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
public interface MouseHandler extends EventHandler, MouseListener, MouseMotionListener {
}
package org.opengis.go.display.event;
public interface MouseManager extends EventManager {
       public void enableMouseHandler(MouseHandler mouseHandler);
       public void pushMouseHandler(MouseHandler mouseHandler);
       public void removeMouseHandler(MouseHandler mouseHandler);
       public boolean replaceMouseHandler(MouseHandler existingHandler,        MouseHandler replacementHandler);
       public MouseHandler getCurrentMouseHandler();
       public MouseHandler[] getFallbackMouseHandlers();
}
package org.opengis.go.display.primitive;
import org.opengis.go.display.event.AggregationChangeEvent;
import org.opengis.go.display.event.AggregationListener;
public interface AggregateGraphic extends Graphic {
       public void setChildren(Graphic[] children);
       public Graphic[] getChildren();
       public Graphic addChild(Graphic child);
       public Graphic removeChild(Graphic child);
       public void removeChildren();
       public Graphic replaceChild(Graphic oldChild, Graphic newChild);
       public int getChildCount();
       public void addAggregationListener(AggregationListener listener);
       public void removeAggregationListener(AggregationListener listener);
       public void aggregationChanged(AggregationChangeEvent event);
}
package org.opengis.go.display.primitive;
import org.opengis.spatialschema.geometry.Geometry;
public class GeometryNotSupportedException extends Exception {
       private final Geometry geometry;
       public GeometryNotSupportedException(Geometry geometry) {
        super("This Geometry is not supported: " + geometry);
        this.geometry = geometry;
    }
       public Geometry getGeometry() {
        return geometry;
    }
}
package org.opengis.go.display.primitive;
import org.opengis.go.display.event.GraphicEvent;
import org.opengis.go.display.event.GraphicListener;
import org.opengis.go.display.style.GraphicStyle;
public interface Graphic {
           public void dispose();
       public void refresh();
           public void setName(String name);
       public String getName();
       public void setParent(Graphic parent);
       public Graphic getParent();
       public GraphicStyle getGraphicStyle();
       public Object getClientProperty(Object key);
       public void putClientProperty(Object key, Object value);
       public void setPassingEventsToParent(boolean passToParent);
       public boolean isPassingEventsToParent();
       public void setShowingEditHandles(boolean showingHandles);
       public boolean isShowingEditHandles();
       public void setShowingAnchorHandles(boolean showingHandles);
       public boolean isShowingAnchorHandles();
           public Graphic cloneGraphic();
           public void addGraphicListener(GraphicListener listener);
       public void removeGraphicListener(GraphicListener listener);
       public void fireGraphicEvent(GraphicEvent ge);
}
package org.opengis.go.display.primitive;
import javax.units.Unit;
import java.util.ArrayList;
import java.util.List;
import org.opengis.go.spatial.PathType;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.geometry.Conic;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public interface GraphicArc extends Graphic {
       public void setArc(        DirectPosition center,        double width,        double height,        Unit lengthUnit,        double rotation,        double start,        double end,        Unit angleUnit);
       public void setCenter(DirectPosition center);
       public DirectPosition getCenter();
       public void setWidth(double width, Unit unit);
       public double getWidth(Unit unit);
       public void setHeight(double height, Unit unit);
       public double getHeight(Unit unit);
       public void setConic(Conic conic) throws GeometryNotSupportedException;
           public Conic getConic();
       public void setRotation(double rotation, Unit unit);
       public double getRotation(Unit unit);
       public void setStart(double start, Unit unit);
       public double getStart(Unit unit);
       public void setEnd(double end, Unit unit);
       public double getEnd(Unit unit);
       public void setClosureType(ArcClosure closureType);
       public ArcClosure getClosureType();
       public boolean isAllowingRotation();
       public void setAllowingRotation(boolean newValue);
       public boolean isCircle();
       public boolean isClosedEllipse();
           public boolean isAllowingExtentsChange();
       public void setAllowingExtentsChange(boolean newValue);
           public void setClosurePathType(PathType pathType);
       public PathType getClosurePathType();
       public static class ArcClosure extends SimpleEnumerationType {
           private static final List VALUES = new ArrayList(3);
               public static final ArcClosure OPEN = new ArcClosure("Open", "");
               public static final ArcClosure CHORD = new ArcClosure("Chord", "");
               public static final ArcClosure PIE = new ArcClosure("Pie", "");
                                                                       private ArcClosure(String name, String description) {
            super(VALUES, name, description);
        }
                      public static ArcClosure[] getArray() {
            return values();
        }
               public static ArcClosure[] values() {
        synchronized (VALUES) {
            return (ArcClosure[]) VALUES.toArray(new ArcClosure[VALUES.size()]);
    }
}
       public CodeList[] family() {
        return values();
    }
            }
  }
package org.opengis.go.display.primitive;
import org.opengis.go.display.event.AggregationChangeEvent;
import org.opengis.go.display.event.AggregationListener;
import org.opengis.spatialschema.geometry.complex.CompositeCurve;
public interface GraphicCompositeCurve extends Graphic {
           public void setCompositeCurve(CompositeCurve compositeCurve) throws GeometryNotSupportedException;
           public CompositeCurve getCompositeCurve();
       public boolean isClosed();
               public void setSegments(Graphic[] segments);
           public Graphic replaceSegment(Graphic oldSegment, Graphic newSegment);
           public void removeSegments();
           public Graphic removeSegment(Graphic segment);
           public Graphic removeSegment(int index);
           public boolean isValid();
           public Graphic insertSegment(int index, Graphic segment);
           public Graphic[] getSegments();
           public int getSegmentCount();
           public Graphic getSegment(int index);
           public Graphic addSegment(Graphic segment);
                       public void addAggregationListener(AggregationListener listener);
                   public void removeAggregationListener(AggregationListener listener);
                       public void aggregationChanged(AggregationChangeEvent event);
}
package org.opengis.go.display.primitive;
import org.opengis.go.spatial.PathType;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.geometry.PointArray;
import org.opengis.spatialschema.geometry.primitive.CurveSegment;
public interface GraphicCurveSegment extends Graphic {
       public void setCurveSegment(CurveSegment curveSegment);
       public CurveSegment getCurveSegment();
       public PointArray getPointArray();
       public void setPointArray(PointArray pointArray);
       public DirectPosition[] getPoints();
       public void setPoints(DirectPosition[] coords);
       public void addPoint(DirectPosition coord);
       public void deletePoint(int index);
       public DirectPosition getPoint(int index);
       public void insertPoint(int index, DirectPosition coord);
       public void setPoint(int index, DirectPosition coord);
       public boolean isClosed();
       public void setClosed(boolean closed);
           public boolean isAllowingNewVertices();
       public void setAllowingNewVertices(boolean newValue);
           public void setPathType(PathType pathType);
       public PathType getPathType();
}
package org.opengis.go.display.primitive;
import java.awt.geom.Point2D;
import javax.swing.Icon;
import javax.units.Unit;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface GraphicIcon extends Graphic {
       public void setIcon(Icon icon);
       public Icon getIcon();
       public void setPosition(DirectPosition coord);
       public DirectPosition getPosition();
       public void setRotation(double angle, Unit unit);
       public double getRotation(Unit unit);
       public void setOffset(Point2D offset);
       public Point2D getOffset();
       public boolean isAllowingRotation();
       public void setAllowingRotation(boolean newValue);
}
package org.opengis.go.display.primitive;
import javax.units.Unit;
import org.opengis.go.display.style.XAnchor;
import org.opengis.go.display.style.YAnchor;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface GraphicLabel extends Graphic {
       public void setText(String text);
       public String getText();
       public void setPosition(DirectPosition coord);
       public DirectPosition getPosition();
       public void setXAnchor(XAnchor xAnchor);
       public XAnchor getXAnchor();
       public void setYAnchor(YAnchor yAnchor);
       public YAnchor getYAnchor();
       public void setRotation(double rotation, Unit unit);
       public double getRotation(Unit unit);
       public boolean isAllowingRotation();
       public void setAllowingRotation(boolean newValue);
}
package org.opengis.go.display.primitive;
import org.opengis.spatialschema.geometry.primitive.Ring;
public interface GraphicRing extends GraphicCompositeCurve {
           public void setRing(Ring ring);
           public Ring getRing();
}
package org.opengis.go.display.primitive;
import java.awt.image.RenderedImage;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.Envelope;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
public interface GraphicScaledImage extends Graphic {
           public void setEnvelope(Envelope envelope);
           public Envelope getEnvelope();
           public void setScaledImage(RenderedImage image);
           public RenderedImage getScaledImage();
           public void setUpperLeft(DirectPosition coord);
           public DirectPosition getUpperLeft();
           public void setLowerRight(DirectPosition coord);
           public DirectPosition getLowerRight();
           public void setIntensity(int intensity);
           public int getIntensity();
           public void setTransparency(int transparency);
           public int getTransparency();
           public void setCRS(CoordinateReferenceSystem crs);
           public CoordinateReferenceSystem getCRS();
}
package org.opengis.go.display.primitive;
import org.opengis.spatialschema.geometry.primitive.SurfaceBoundary;
public interface GraphicSurfaceBoundary extends Graphic {
           public void setSurfaceBoundary(SurfaceBoundary surfaceBoundary);
           public SurfaceBoundary getSurfaceBoundary();
           public GraphicRing getExterior();
       public void setExterior(GraphicRing exterior);
               public GraphicRing[] getInteriors();
                          public void setInteriors(GraphicRing[] interiors);
}
package org.opengis.go.display.primitive;
import org.opengis.go.display.style.Symbology;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.geometry.PointArray;
public interface GraphicSymbol extends Graphic {
           public void addAnchorPoint(DirectPosition anchor);
           public void deleteAnchorPoint(int index) throws IndexOutOfBoundsException;
           public DirectPosition getAnchorPoint(int index)         throws IndexOutOfBoundsException;
           public void insertAnchorPoint(int index, DirectPosition anchor)         throws IndexOutOfBoundsException;
           public void setAnchorPoint(int index, DirectPosition anchor)         throws IndexOutOfBoundsException;
           public void setAnchorPoints(DirectPosition[] anchors);
           public DirectPosition[] getAnchorPoints();
           public void setAnchorPointArray(PointArray pointArray);
           public PointArray getAnchorPointArray();
           public Symbology getSymbology(String symbologyName);
           public String getActiveSymbology();
           public void setActiveSymbology(String symbologyName) throws IllegalArgumentException;
           public String getSymbologyVersion();
       public void setSymbologyVersion(String symbologyVersion) throws IllegalArgumentException;
    }
package org.opengis.go.display.primitive;
public interface OrderedAggregateGraphic extends AggregateGraphic {
       public Graphic insertChild(int index, Graphic child);
       public Graphic getChild(int index);
       public Graphic removeChild(int index);
}
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class ArrowStyle extends SimpleEnumerationType {
                   private static final List VALUES = new ArrayList(4);
       public static final ArrowStyle NONE = new ArrowStyle("NONE", "No arrow head will be drawn");
       public static final ArrowStyle OPEN_ARROW =        new ArrowStyle("OPEN_ARROW", "Single line with an open arrowhead.");
       public static final ArrowStyle SOLID_ARROW =        new ArrowStyle("SOLID_ARROW", "Single line with a filled arrowhead.");
       public static final ArrowStyle BROAD_ARROW        = new ArrowStyle("BROAD_ARROW",                         "Double line with large arrowhead.");
                   protected ArrowStyle(String name, String description) {
        super(VALUES, name, description, loadIconResource(ArrowStyle.class, name + ".gif"));
    }
                   public static ArrowStyle[] values() {
        synchronized (VALUES) {
            return (ArrowStyle[]) VALUES.toArray(new ArrowStyle[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go.display.style;
public class DashArray extends LinePattern {
                       public static final DashArray NONE = new DashArray("NONE", "No Dash Array", new float[0]);
                   private float[] dashPattern;
                   public DashArray(String name, String description, float[] pattern) {
        super(name, description);
        dashPattern = pattern;
    }
                   public float[] getDashPattern() {
        return dashPattern;
    }
}
package org.opengis.go.display.style;
public interface Editability {
                              public static final String EDITABILITY_AUTO_EDIT = "EDITABILITY_AUTO_EDIT";
        public static final String EDITABILITY_DRAG_SELECTABLE = "EDITABILITY_DRAG_SELECTABLE";
        public static final String EDITABILITY_PICKABLE = "EDITABILITY_PICKABLE";
        public static final String EDITABILITY_SELECTED = "EDITABILITY_SELECTED";
                     public static final boolean DEFAULT_EDITABILITY_AUTO_EDIT = true;
       public static final boolean DEFAULT_EDITABILITY_DRAG_SELECTABLE = true;
       public static final boolean DEFAULT_EDITABILITY_PICKABLE = true;
       public static final boolean DEFAULT_EDITABILITY_SELECTED = false;
                           public boolean getEditabilityAutoEdit();
               public boolean isEditabilityAutoEditSet();
               public void setEditabilityAutoEdit(boolean autoEdit);
               public void setEditabilityAutoEditSet(boolean flag);
          public boolean getEditabilityDragSelectable();
               public boolean isEditabilityDragSelectableSet();
               public void setEditabilityDragSelectable(boolean dragSelectable);
               public void setEditabilityDragSelectableSet(boolean flag);
             public boolean getEditabilityPickable();
               public boolean isEditabilityPickableSet();
               public void setEditabilityPickable(boolean pickable);
               public void setEditabilityPickableSet(boolean flag);
          public boolean getEditabilitySelected();
               public boolean isEditabilitySelectedSet();
               public void setEditabilitySelected(boolean selected);
               public void setEditabilitySelectedSet(boolean flag);
   }
package org.opengis.go.display.style;
import java.awt.Color;
public interface Fill {
       public static final String COLOR = "FILL_COLOR";
       public static final String BACKGROUND_COLOR = "FILL_BACKGROUND_COLOR";
           public static final String GRADIENT_POINTS = "FILL_GRADIENT_POINTS";
       public static final String OPACITY = "FILL_OPACITY";
           public static final String FILL_PATTERN = "FILL_PATTERN";
       public static final String FILL_STYLE = "FILL_STYLE";
           public Color getColor();
               public boolean isColorSet();
               public void setColor(Color fillColor);
               public void setColorSet(boolean flag);
          public Color getBackgroundColor();
               public boolean isBackgroundColorSet();
               public void setBackgroundColor(Color fillBackgroundColor);
               public void setBackgroundColorSet(boolean flag);
           public float[] getGradientPoints();
               public boolean isGradientPointsSet();
               public void setGradientPoints(float[] fillGradientPoints);
               public void setGradientPointsSet(boolean flag);
          public float getOpacity();
               public boolean isOpacitySet();
               public void setOpacity(float fillOpacity);
               public void setOpacitySet(boolean flag);
          public FillPattern getFillPattern();
               public boolean isFillPatternSet();
               public void setFillPattern(FillPattern fillPattern);
               public void setFillPatternSet(boolean flag);
          public FillStyle getFillStyle();
               public boolean isFillStyleSet();
               public void setFillStyle(FillStyle fillStyle);
               public void setFillStyleSet(boolean flag);
}
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class FillPattern extends SimpleEnumerationType {
                   private static final List VALUES = new ArrayList(11);
       public static final FillPattern NONE = new FillPattern("NONE", "No fill.");
       public static final FillPattern DOTS =        new FillPattern("DOTS", "Regularly spaced single pixels.");
       public static final FillPattern VERTICAL_LINES =        new FillPattern("VERTICAL_LINES", "Parallel vertical lines.");
       public static final FillPattern HORIZONTAL_LINES =        new FillPattern("HORIZONTAL_LINES", "Parallel horizontal lines.");
       public static final FillPattern NEGATIVE_SLANTS =        new FillPattern(            "NEGATIVE_SLANTS",            "Parallel slanted lines running from upper left to lower right.");
       public static final FillPattern POSITIVE_SLANTS =        new FillPattern(            "POSITIVE_SLANTS",            "Parallel slanted lines running from lower left to upper right.");
       public static final FillPattern PLUSSES =        new FillPattern("PLUSSES", "Small closely spaced '+' marks.");
       public static final FillPattern XHATCH =        new FillPattern("XHATCH", "Two series of intersecting parallel lines.");
       public static final FillPattern FILL_25_PERCENT =        new FillPattern("FILL_25_PERCENT", "25% fill.  Can be used to simulate transparency.");
       public static final FillPattern FILL_50_PERCENT =        new FillPattern("FILL_50_PERCENT", "50% fill.  Can be used to simulate transparency.");
       public static final FillPattern FILL_75_PERCENT        = new FillPattern("FILL_75_PERCENT", "75% fill.  Can be used to simulate transparency.");
                   protected FillPattern(String name, String description) {
        super(VALUES, name, description, loadIconResource(FillPattern.class, name + ".gif"));
    }
                   public static FillPattern[] values() {
        synchronized (VALUES) {
            return (FillPattern[]) VALUES.toArray(new FillPattern[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class FillStyle extends SimpleEnumerationType {
                   private static final List VALUES = new ArrayList(5);
       public static final FillStyle SOLID = new FillStyle("SOLID", "Fill entirely with the color.");
       public static final FillStyle EMPTY = new FillStyle("EMPTY", "Do not fill.");
       public static final FillStyle STIPPLED =        new FillStyle("STIPPLED", "Fill using a transparent, tiled pattern.");
       public static final FillStyle OPAQUE_STIPPLED =        new FillStyle("OPAQUE_STIPPLED", "Fill using an opaque, tiled pattern.");
       public static final FillStyle GRADIENT =            new FillStyle("GRADIENT",                    "Fill using a smooth transition between the current " +                    "foreground and background colors.");
                   protected FillStyle(String name, String description) {
        super(VALUES, name, description);
    }
       public static FillStyle[] values() {
        synchronized (VALUES) {
            return (FillStyle[]) VALUES.toArray(new FillStyle[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go.display.style;
import org.opengis.go.display.primitive.Graphic;
public interface GraphicStyle extends Editability, Highlight, Symbology, Viewability,         LineSymbolizer, PointSymbolizer, PolygonSymbolizer, TextSymbolizer {
                                   public static final String EDITABILITY = "EDITABILITY";
           public static final String HIGHLIGHT = "HIGHLIGHT";
           public static final String SYMBOLOGY = "SYMBOLOGY";
           public static final String VIEWABILITY = "VIEWABILITY";
           public static final String LINE_SYMBOLIZER = "LINE_SYMBOLIZER";
           public static final String POLYGON_SYMBOLIZER = "POLYGON_SYMBOLIZER";
           public static final String POINT_SYMBOLIZER = "POINT_SYMBOLIZER";
           public static final String TEXT_SYMBOLIZER = "TEXT_SYMBOLIZER";
                   public static final String INHERIT_STYLE_FROM_PARENT = "INHERIT_STYLE_FROM_PARENT";
       public static final String OVERRIDE_AGGREGATED_GRAPHICS = "OVERRIDE_AGGREGATED_GRAPHICS";
                   public static final boolean DEFAULT_INHERIT_STYLE_FROM_PARENT = false;
       public static final boolean DEFAULT_OVERRIDE_AGGREGATED_GRAPHICS = false;
                                                  public Graphic getGraphic();
           public Object getImplHint(String hintName);
           public void setImplHint(String hintname, Object hint);
           public void setPropertiesFrom(GraphicStyle style);
                   public Editability getEditability();
           public void setEditability(Editability object);
           public Highlight getHighlight();
           public void setHighlight(Highlight object);
           public Symbology getSymbology();
           public void setSymbology(Symbology object);
           public Viewability getViewability();
           public void setViewability(Viewability object);
               public LineSymbolizer getLineSymbolizer();
       public void setLineSymbolizer(LineSymbolizer object);
           public PointSymbolizer getPointSymbolizer();
       public void setPointSymbolizer(PointSymbolizer object);
       public PolygonSymbolizer getPolygonSymbolizer();
       public void setPolygonSymbolizer(PolygonSymbolizer object);
       public TextSymbolizer getTextSymbolizer();
       public void setTextSymbolizer(TextSymbolizer object);
               public boolean isInheritingStyleFromParent();
               public void setInheritingStyleFromParent(boolean inheritStyleFromParent);
           public boolean isOverridingAggregatedGraphics();
               public void setOverridingAggregatedGraphics(boolean overrideAggregatedGraphics);
           }
package org.opengis.go.display.style;
public interface Halo {
       public static final String RADIUS = "HALO_RADIUS";
       public float getRadius();
           public boolean isRadiusSet();
           public void setRadius(float haloRadius);
           public void setRadiusSet(boolean flag);
}
package org.opengis.go.display.style;
public interface Highlight {
                                public static final String HIGHLIGHT_BLINK_PATTERN = "HIGHLIGHT_BLINK_PATTERN";
        public static final String HIGHLIGHT_BLINKING = "HIGHLIGHT_BLINKING";
                   public static final boolean DEFAULT_HIGHLIGHT_BLINKING = false;
       public static final float[] DEFAULT_HIGHLIGHT_BLINK_PATTERN = {
0.5f, 0.5f}
;
                           public boolean getHighlightBlinking();
               public boolean isHighlightBlinkingSet();
               public void setHighlightBlinking(boolean blinking);
               public void setHighlightBlinkingSet(boolean flag);
          public float[] getHighlightBlinkPattern();
               public boolean isHighlightBlinkPatternSet();
               public void setHighlightBlinkPattern(float[] blinkPattern);
               public void setHighlightBlinkPatternSet(boolean flag);
   }
package org.opengis.go.display.style;
public interface Inheritance {
       public static final boolean DEFAULT_INHERIT_STYLE_FROM_PARENT = false;
       public static final boolean DEFAULT_OVERRIDE_AGGREGATED_GRAPHICS = false;
           public static final String INHERIT_STYLE_FROM_PARENT = "INHERITANCE_INHERIT_STYLE_FROM_PARENT";
       public static final String OVERRIDE_AGGREGATED_GRAPHICS = "INHERITANCE_OVERRIDE_AGGREGATED_GRAPHICS";
                   public boolean isInheritingStyleFromParent();
               public boolean isInheritingStyleFromParentSet();
               public void setInheritingStyleFromParent(boolean inheritStyleFromParent);
               public void setInheritingStyleFromParentSet(boolean flag);
        public boolean isOverridingAggregatedGraphics();
               public boolean isOverridingAggregatedGraphicsSet();
               public void setOverridingAggregatedGraphics(boolean overrideAggregatedGraphics);
               public void setOverridingAggregatedGraphicsSet(boolean flag);
}
package org.opengis.go.display.style;
public interface LabelPlacement {
       public static final String LABEL = "LABELPLACEMENT_LABEL";
           public static final String ROTATION = "LABELPLACEMENT_ROTATION";
           public static final String XANCHOR = "LABELPLACEMENT_XANCHOR";
           public static final String XDISPLACEMENT = "LABELPLACEMENT_XDISPLACEMENT";
           public static final String YANCHOR = "LABELPLACEMENT_YANCHOR";
        public static final String YDISPLACEMENT = "LABELPLACEMENT_YDISPLACEMENT";
           public static final String SHOW_LABEL = "LABELPLACEMENT_SHOW_LABEL";
       public String getLabel();
               public boolean isLabelSet();
               public void setLabel(String label);
               public void setLabelSet(boolean flag);
           public float getRotation();
               public boolean isRotationSet();
               public void setRotation(float labelRotation);
               public void setRotationSet(boolean flag);
          public XAnchor getXAnchor();
               public boolean isXAnchorSet();
               public void setXAnchor(XAnchor labelXAnchor);
               public void setXAnchorSet(boolean flag);
          public float getXDisplacement();
               public boolean isXDisplacementSet();
               public void setXDisplacement(float labelXDisplacement);
               public void setXDisplacementSet(boolean flag);
          public YAnchor getYAnchor();
               public boolean isYAnchorSet();
               public void setYAnchor(YAnchor labelYAnchor);
               public void setYAnchorSet(boolean flag);
          public float getYDisplacement();
               public boolean isYDisplacementSet();
               public void setYDisplacement(float labelYDisplacement);
               public void setYDisplacementSet(boolean flag);
          public boolean getShowLabel();
               public boolean isShowLabelSet();
               public void setShowLabel(boolean showLabel);
               public void setShowLabelSet(boolean flag);
}
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class LineCap extends SimpleEnumerationType {
                   private static final List VALUES = new ArrayList(3);
       public static final LineCap BUTT = new LineCap("BUTT", "Draw line ends with no decoration.");
       public static final LineCap ROUND = new LineCap("ROUND", "Draw line ends with half circles.");
       public static final LineCap SQUARE =            new LineCap("SQUARE", "Draw line ends with a square cap.");
                   protected LineCap(String name, String description) {
        super(VALUES, name, description);
    }
                   public static LineCap[] values() {
        synchronized (VALUES) {
            return (LineCap[]) VALUES.toArray(new LineCap[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class LineJoin extends SimpleEnumerationType {
                       private static final List VALUES = new ArrayList(3);
           public static final LineJoin MITER =        new LineJoin("MITER", "Join lines by extending outside edges until they meet.");
               public static final LineJoin ROUND =        new LineJoin("ROUND", "Join lines with a circular arc equal to hald the line width.");
               public static final LineJoin BEVEL =            new LineJoin("BEVEL",                    "Joine lines by connecting outer corners with a segment.");
                           protected LineJoin(String name, String description) {
        super(VALUES, name, description);
    }
                           public static LineJoin[] values() {
        synchronized (VALUES) {
            return (LineJoin[]) VALUES.toArray(new LineJoin[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class LinePattern extends SimpleEnumerationType {
                       private static final List VALUES = new ArrayList(6);
           public static final LinePattern NONE = new LinePattern("NONE", "A line with no pattern.");
           public static final LinePattern DASHED = new LinePattern("DASHED", "A dashed line");
           public static final LinePattern DOTTED = new LinePattern("DOTTED", "A dotted line");
           public static final LinePattern DOT_DASHED = new LinePattern("DOT_DASHED", "Dot dashed line");
           public static final LinePattern LONG_DASHED =        new LinePattern("LONG_DASHED", "Long dashed line");
               public static final LinePattern LONG_DOT_DASHED            = new LinePattern("LONG_DOT_DASHED", "Long dot dashed line");
                        protected LinePattern(String name, String description) {
        super(VALUES, name, description, loadIconResource(LinePattern.class, name + ".gif"));
    }
       public static LinePattern[] values() {
        synchronized (VALUES) {
            return (LinePattern[]) VALUES.toArray(new LinePattern[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class LineStyle extends SimpleEnumerationType {
                       private static final List VALUES = new ArrayList(2);
           public static final LineStyle SINGLE = new LineStyle("SINGLE", "Single Line");
           public static final LineStyle DOUBLE        = new LineStyle("DOUBLE", "Double Line");
                           protected LineStyle(String name, String description) {
        super(VALUES, name, description, loadIconResource(LineStyle.class, name + ".gif"));
}
                   public static LineStyle[] values() {
        synchronized (VALUES) {
            return (LineStyle[]) VALUES.toArray(new LineStyle[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go.display.style;
import java.awt.Color;
public interface LineSymbolizer {
                                public static final String LINE_STROKE_BEGIN_ARROW_STYLE = "LINE_STROKE_BEGIN_ARROW_STYLE";
    public static final String LINE_STROKE_END_ARROW_STYLE = "LINE_STROKE_END_ARROW_STYLE";
    public static final String LINE_STROKE_COLOR = "LINE_STROKE_COLOR";
        public static final String LINE_STROKE_DASH_ARRAY = "LINE_STROKE_DASH_ARRAY";
    public static final String LINE_STROKE_DASH_OFFSET = "LINE_STROKE_DASH_OFFSET";
    public static final String LINE_STROKE_FILL_BACKGROUND_COLOR = "LINE_STROKE_FILL_BACKGROUND_COLOR";
    public static final String LINE_STROKE_FILL_COLOR = "LINE_STROKE_FILL_COLOR";
    public static final String LINE_STROKE_FILL_GRADIENT_POINTS = "LINE_STROKE_FILL_GRADIENT_POINTS";
     public static final String LINE_STROKE_FILL_OPACITY = "LINE_STROKE_FILL_OPACITY";
    public static final String LINE_STROKE_FILL_PATTERN = "LINE_STROKE_FILL_PATTERN";
    public static final String LINE_STROKE_FILL_STYLE = "LINE_STROKE_FILL_STYLE";
    public static final String LINE_STROKE_LINE_CAP = "LINE_STROKE_LINE_CAP";
    public static final String LINE_STROKE_LINE_GAP = "LINE_STROKE_LINE_GAP";
    public static final String LINE_STROKE_LINE_JOIN = "LINE_STROKE_LINE_JOIN";
    public static final String LINE_STROKE_LINE_STYLE = "LINE_STROKE_LINE_STYLE";
    public static final String LINE_STROKE_OPACITY = "LINE_STROKE_OPACITY";
    public static final String LINE_STROKE_PATTERN = "LINE_STROKE_PATTERN";
    public static final String LINE_STROKE_WIDTH = "LINE_STROKE_WIDTH";
                   public static final ArrowStyle DEFAULT_LINE_STROKE_BEGIN_ARROW_STYLE = ArrowStyle.NONE;
       public static final ArrowStyle DEFAULT_LINE_STROKE_END_ARROW_STYLE = ArrowStyle.NONE;
       public static final Color DEFAULT_LINE_STROKE_COLOR = Color.BLACK;
       public static final DashArray DEFAULT_LINE_STROKE_DASH_ARRAY = (DashArray)LinePattern.NONE;
       public static final float DEFAULT_LINE_STROKE_DASH_OFFSET = 0.f;
    public static final Color DEFAULT_LINE_STROKE_FILL_BACKGROUND_COLOR = Color.WHITE;
        public static final Color DEFAULT_LINE_STROKE_FILL_COLOR = Color.BLACK;
        public static final float[] DEFAULT_LINE_STROKE_FILL_GRADIENT_POINTS = new float[0];
        public static final float DEFAULT_LINE_STROKE_FILL_OPACITY = 1.f;
        public static final FillPattern DEFAULT_LINE_STROKE_FILL_PATTERN = FillPattern.NONE;
        public static final FillStyle DEFAULT_LINE_STROKE_FILL_STYLE = FillStyle.SOLID;
       public static final LineCap DEFAULT_LINE_STROKE_LINE_CAP = LineCap.BUTT;
       public static final float DEFAULT_LINE_STROKE_LINE_GAP = 10.f;
       public static final LineJoin DEFAULT_LINE_STROKE_LINE_JOIN = LineJoin.BEVEL;
    public static final LinePattern DEFAULT_LINE_STROKE_LINE_PATTERN = LinePattern.NONE;
       public static final LineStyle DEFAULT_LINE_STROKE_LINE_STYLE = LineStyle.SINGLE;
       public static final float DEFAULT_LINE_STROKE_OPACITY = 1.f;
       public static final float DEFAULT_LINE_STROKE_WIDTH = 1.f;
                   public ArrowStyle getLineStrokeBeginArrowStyle();
               public boolean isLineStrokeBeginArrowStyleSet();
               public void setLineStrokeBeginArrowStyle(ArrowStyle strokeArrowStyle);
               public void setLineStrokeBeginArrowStyleSet(boolean flag);
           public ArrowStyle getLineStrokeEndArrowStyle();
               public boolean isLineStrokeEndArrowStyleSet();
               public void setLineStrokeEndArrowStyle(ArrowStyle strokeArrowStyle);
               public void setLineStrokeEndArrowStyleSet(boolean flag);
             public Color getLineStrokeColor();
               public boolean isLineStrokeColorSet();
               public void setLineStrokeColor(Color strokeColor);
               public void setLineStrokeColorSet(boolean flag);
          public DashArray getLineStrokeDashArray();
               public boolean isLineStrokeDashArraySet();
               public void setLineStrokeDashArray(DashArray strokeDashArray);
               public void setLineStrokeDashArraySet(boolean flag);
          public float getLineStrokeDashOffset();
               public boolean isLineStrokeDashOffsetSet();
               public void setLineStrokeDashOffset(float strokeDashOffset);
               public void setLineStrokeDashOffsetSet(boolean flag);
          public Color getLineStrokeFillColor();
           public boolean isLineStrokeFillColorSet();
           public void setLineStrokeFillColor(Color fillColor);
           public void setLineStrokeFillColorSet(boolean flag);
          public Color getLineStrokeFillBackgroundColor();
           public boolean isLineStrokeFillBackgroundColorSet();
           public void setLineStrokeFillBackgroundColor(Color fillBackgroundColor);
           public void setLineStrokeFillBackgroundColorSet(boolean flag);
       public float[] getLineStrokeFillGradientPoints();
           public boolean isLineStrokeFillGradientPointsSet();
           public void setLineStrokeFillGradientPoints(float[] fillGradientPoints);
           public void setLineStrokeFillGradientPointsSet(boolean flag);
          public float getLineStrokeFillOpacity();
           public boolean isLineStrokeFillOpacitySet();
           public void setLineStrokeFillOpacity(float fillOpacity);
           public void setLineStrokeFillOpacitySet(boolean flag);
          public FillPattern getLineStrokeFillPattern();
           public boolean isLineStrokeFillPatternSet();
           public void setLineStrokeFillPattern(FillPattern fillPattern);
           public void setLineStrokeFillPatternSet(boolean flag);
          public FillStyle getLineStrokeFillStyle();
           public boolean isLineStrokeFillStyleSet();
           public void setLineStrokeFillStyle(FillStyle fillStyle);
           public void setLineStrokeFillStyleSet(boolean flag);
             public LineCap getLineStrokeLineCap();
               public boolean isLineStrokeLineCapSet();
               public void setLineStrokeLineCap(LineCap strokeLineCap);
               public void setLineStrokeLineCapSet(boolean flag);
          public float getLineStrokeLineGap();
               public boolean isLineStrokeLineGapSet();
               public void setLineStrokeLineGap(float strokeLineGap);
               public void setLineStrokeLineGapSet(boolean flag);
            public LineJoin getLineStrokeLineJoin();
               public boolean isLineStrokeLineJoinSet();
               public void setLineStrokeLineJoin(LineJoin strokeLineJoin);
               public void setLineStrokeLineJoinSet(boolean flag);
            public LinePattern getLineStrokeLinePattern();
               public boolean isLineStrokeLinePatternSet();
               public void setLineStrokeLinePattern(LinePattern strokeLinePattern);
               public void setLineStrokeLinePatternSet(boolean flag);
            public LineStyle getLineStrokeLineStyle();
               public boolean isLineStrokeLineStyleSet();
               public void setLineStrokeLineStyle(LineStyle strokeLineStyle);
               public void setLineStrokeLineStyleSet(boolean flag);
            public float getLineStrokeOpacity();
               public boolean isLineStrokeOpacitySet();
               public void setLineStrokeOpacity(float opacity);
               public void setLineStrokeOpacitySet(boolean flag);
          public float getLineStrokeWidth();
               public boolean isLineStrokeWidthSet();
               public void setLineStrokeWidth(float width);
               public void setLineStrokeWidthSet(boolean flag);
}
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class Mark extends SimpleEnumerationType {
                   private static final List VALUES = new ArrayList(7);
       public static final Mark CUSTOM =        new Mark("CUSTOM", "Symbolize with a custom mark.");
       public static final Mark CIRCLE =        new Mark("CIRCLE", "Symbolize with a circle mark.");
       public static final Mark CROSS =        new Mark("CROSS", "Symbolize with a cross mark.");
       public static final Mark SQUARE =        new Mark("SQUARE", "Symbolize with a square mark.");
       public static final Mark STAR =        new Mark("STAR", "Symbolize with a star mark.");
       public static final Mark TRIANGLE =        new Mark("TRIANGLE", "Symbolize with a triangle mark.");
       public static final Mark X =            new Mark("X", "Symbolize with an X mark.");
                   protected Mark(String name, String description) {
        super(VALUES, name, description);
    }
                           public static Mark[] values() {
        synchronized (VALUES) {
            return (Mark[]) VALUES.toArray(new Mark[VALUES.size()]);
    }
}
       public CodeList[] family() {
        return  values();
    }
}
package org.opengis.go.display.style;
import java.awt.Color;
public interface PointSymbolizer {
                                public static final String POINT_FILL_BACKGROUND_COLOR = "POINT_FILL_BACKGROUND_COLOR";
    public static final String POINT_FILL_COLOR = "POINT_FILL_COLOR";
    public static final String POINT_FILL_GRADIENT_POINTS = "POINT_FILL_GRADIENT_POINTS";
     public static final String POINT_FILL_OPACITY = "POINT_FILL_OPACITY";
    public static final String POINT_FILL_PATTERN = "POINT_FILL_PATTERN";
    public static final String POINT_FILL_STYLE = "POINT_FILL_STYLE";
    public static final String POINT_MARK = "POINT_MARK";
    public static final String POINT_OPACITY = "POINT_OPACITY";
    public static final String POINT_ROTATION = "POINT_ROTATION";
    public static final String POINT_SIZE = "POINT_SIZE";
    public static final String POINT_STROKE_BEGIN_ARROW_STYLE = "POINT_STROKE_BEGIN_ARROW_STYLE";
    public static final String POINT_STROKE_END_ARROW_STYLE = "POINT_STROKE_END_ARROW_STYLE";
    public static final String POINT_STROKE_COLOR = "POINT_STROKE_COLOR";
     public static final String POINT_STROKE_DASH_ARRAY = "POINT_STROKE_DASH_ARRAY";
    public static final String POINT_STROKE_DASH_OFFSET = "POINT_STROKE_DASH_OFFSET";
    public static final String POINT_STROKE_FILL_BACKGROUND_COLOR = "POINT_STROKE_FILL_BACKGROUND_COLOR";
    public static final String POINT_STROKE_FILL_COLOR = "POINT_STROKE_FILL_COLOR";
    public static final String POINT_STROKE_FILL_GRADIENT_POINTS = "POINT_STROKE_FILL_GRADIENT_POINTS";
     public static final String POINT_STROKE_FILL_OPACITY = "POINT_STROKE_FILL_OPACITY";
    public static final String POINT_STROKE_FILL_PATTERN = "POINT_STROKE_FILL_PATTERN";
    public static final String POINT_STROKE_FILL_STYLE = "POINT_STROKE_FILL_STYLE";
    public static final String POINT_STROKE_LINE_CAP = "POINT_STROKE_LINE_CAP";
    public static final String POINT_STROKE_LINE_GAP = "POINT_STROKE_LINE_GAP";
    public static final String POINT_STROKE_LINE_JOIN = "POINT_STROKE_LINE_JOIN";
    public static final String POINT_STROKE_LINE_PATTERN = "POINT_STROKE_LINE_PATTERN";
    public static final String POINT_STROKE_LINE_STYLE = "POINT_STROKE_LINE_STYLE";
    public static final String POINT_STROKE_OPACITY = "POINT_STROKE_OPACITY";
    public static final String POINT_STROKE_WIDTH = "POINT_STROKE_WIDTH";
    public static final String POINT_STROKE_PATTERN = "POINT_STROKE_PATTERN";
                       public static final Color DEFAULT_POINT_FILL_BACKGROUND_COLOR = Color.BLACK;
           public static final Color DEFAULT_POINT_FILL_COLOR = Color.GRAY;
       public static final float[] DEFAULT_POINT_FILL_GRADIENT_POINTS = new float[2];
       public static final float DEFAULT_POINT_FILL_OPACITY = 1.f;
       public static final FillPattern DEFAULT_POINT_FILL_PATTERN = FillPattern.NONE;
       public static final FillStyle DEFAULT_POINT_FILL_STYLE = FillStyle.SOLID;
           public static final Mark DEFAULT_POINT_MARK = Mark.CIRCLE;
       public static final float DEFAULT_POINT_OPACITY = 1.f;
           public static final float DEFAULT_POINT_ROTATION = 0.f;
       public static final float DEFAULT_POINT_SIZE = 16.f;
               public static final ArrowStyle DEFAULT_POINT_STROKE_BEGIN_ARROW_STYLE = ArrowStyle.NONE;
                   public static final ArrowStyle DEFAULT_POINT_STROKE_END_ARROW_STYLE = ArrowStyle.NONE;
       public static final Color DEFAULT_POINT_STROKE_COLOR = Color.BLACK;
                  public static final DashArray DEFAULT_POINT_STROKE_DASH_ARRAY = (DashArray) DashArray.NONE;
                   public static final float DEFAULT_POINT_STROKE_DASH_OFFSET = 0.f;
       public static final Color DEFAULT_POINT_STROKE_FILL_COLOR = Color.GRAY;
       public static final Color DEFAULT_POINT_STROKE_FILL_BACKGROUND_COLOR = Color.BLACK;
       public static final float[] DEFAULT_POINT_STROKE_FILL_GRADIENT_POINTS = new float[2];
       public static final float DEFAULT_POINT_STROKE_FILL_OPACITY = 1.f;
       public static final FillPattern DEFAULT_POINT_STROKE_FILL_PATTERN = FillPattern.NONE;
       public static final FillStyle DEFAULT_POINT_STROKE_FILL_STYLE = FillStyle.SOLID;
                   public static final LineCap DEFAULT_POINT_STROKE_LINE_CAP = LineCap.BUTT;
                   public static final float DEFAULT_POINT_STROKE_LINE_GAP = 10.f;
                   public static final LineJoin DEFAULT_POINT_STROKE_LINE_JOIN = LineJoin.BEVEL;
        public static final LinePattern DEFAULT_POINT_STROKE_LINE_PATTERN = LinePattern.NONE;
                   public static final LineStyle DEFAULT_POINT_STROKE_LINE_STYLE = LineStyle.SINGLE;
                   public static final float DEFAULT_POINT_STROKE_OPACITY = 1.f;
                  public static final float DEFAULT_POINT_STROKE_WIDTH = 1.f;
                           public Color getPointFillColor();
           public boolean isPointFillColorSet();
           public void setPointFillColor(Color fillColor);
           public void setPointFillColorSet(boolean flag);
          public Color getPointFillBackgroundColor();
           public boolean isPointFillBackgroundColorSet();
           public void setPointFillBackgroundColor(Color fillBackgroundColor);
           public void setPointFillBackgroundColorSet(boolean flag);
       public float[] getPointFillGradientPoints();
           public boolean isPointFillGradientPointsSet();
           public void setPointFillGradientPoints(float[] fillGradientPoints);
           public void setPointFillGradientPointsSet(boolean flag);
          public float getPointFillOpacity();
           public boolean isPointFillOpacitySet();
           public void setPointFillOpacity(float fillOpacity);
           public void setPointFillOpacitySet(boolean flag);
          public FillPattern getPointFillPattern();
           public boolean isPointFillPatternSet();
           public void setPointFillPattern(FillPattern fillPattern);
           public void setPointFillPatternSet(boolean flag);
          public FillStyle getPointFillStyle();
           public boolean isPointFillStyleSet();
           public void setPointFillStyle(FillStyle fillStyle);
           public void setPointFillStyleSet(boolean flag);
               public Mark getPointMark();
               public boolean isPointMarkSet();
               public void setPointMark(Mark pointMark);
               public void setPointMarkSet(boolean flag);
           public float getPointOpacity();
               public boolean isPointOpacitySet();
               public void setPointOpacity(float pointOpacity);
               public void setPointOpacitySet(boolean flag);
          public float getPointRotation();
               public boolean isPointRotationSet();
               public void setPointRotation(float pointRotation);
               public void setPointRotationSet(boolean flag);
          public float getPointSize();
               public boolean isPointSizeSet();
               public void setPointSize(float pointSize);
               public void setPointSizeSet(boolean flag);
          public ArrowStyle getPointStrokeBeginArrowStyle();
               public boolean isPointStrokeBeginArrowStyleSet();
               public void setPointStrokeBeginArrowStyle(ArrowStyle strokeArrowStyle);
               public void setPointStrokeBeginArrowStyleSet(boolean flag);
           public ArrowStyle getPointStrokeEndArrowStyle();
               public boolean isPointStrokeEndArrowStyleSet();
               public void setPointStrokeEndArrowStyle(ArrowStyle strokeArrowStyle);
               public void setPointStrokeEndArrowStyleSet(boolean flag);
             public Color getPointStrokeColor();
               public boolean isPointStrokeColorSet();
               public void setPointStrokeColor(Color strokeColor);
               public void setPointStrokeColorSet(boolean flag);
          public DashArray getPointStrokeDashArray();
               public boolean isPointStrokeDashArraySet();
               public void setPointStrokeDashArray(DashArray strokeDashArray);
               public void setPointStrokeDashArraySet(boolean flag);
          public float getPointStrokeDashOffset();
               public boolean isPointStrokeDashOffsetSet();
               public void setPointStrokeDashOffset(float strokeDashOffset);
               public void setPointStrokeDashOffsetSet(boolean flag);
          public Color getPointStrokeFillColor();
           public boolean isPointStrokeFillColorSet();
           public void setPointStrokeFillColor(Color fillColor);
           public void setPointStrokeFillColorSet(boolean flag);
          public Color getPointStrokeFillBackgroundColor();
           public boolean isPointStrokeFillBackgroundColorSet();
           public void setPointStrokeFillBackgroundColor(Color fillBackgroundColor);
           public void setPointStrokeFillBackgroundColorSet(boolean flag);
       public float[] getPointStrokeFillGradientPoints();
           public boolean isPointStrokeFillGradientPointsSet();
           public void setPointStrokeFillGradientPoints(float[] fillGradientPoints);
           public void setPointStrokeFillGradientPointsSet(boolean flag);
          public float getPointStrokeFillOpacity();
           public boolean isPointStrokeFillOpacitySet();
           public void setPointStrokeFillOpacity(float fillOpacity);
           public void setPointStrokeFillOpacitySet(boolean flag);
          public FillPattern getPointStrokeFillPattern();
           public boolean isPointStrokeFillPatternSet();
           public void setPointStrokeFillPattern(FillPattern fillPattern);
           public void setPointStrokeFillPatternSet(boolean flag);
          public FillStyle getPointStrokeFillStyle();
           public boolean isPointStrokeFillStyleSet();
           public void setPointStrokeFillStyle(FillStyle fillStyle);
           public void setPointStrokeFillStyleSet(boolean flag);
             public LineCap getPointStrokeLineCap();
               public boolean isPointStrokeLineCapSet();
               public void setPointStrokeLineCap(LineCap strokeLineCap);
               public void setPointStrokeLineCapSet(boolean flag);
          public float getPointStrokeLineGap();
               public boolean isPointStrokeLineGapSet();
               public void setPointStrokeLineGap(float strokeLineGap);
               public void setPointStrokeLineGapSet(boolean flag);
            public LineJoin getPointStrokeLineJoin();
               public boolean isPointStrokeLineJoinSet();
               public void setPointStrokeLineJoin(LineJoin strokeLineJoin);
               public void setPointStrokeLineJoinSet(boolean flag);
           public LinePattern getPointStrokeLinePattern();
           public boolean isPointStrokeLinePatternSet();
           public void setPointStrokeLinePattern(LinePattern strokeLinePattern);
           public void setPointStrokeLinePatternSet(boolean flag);
             public LineStyle getPointStrokeLineStyle();
               public boolean isPointStrokeLineStyleSet();
               public void setPointStrokeLineStyle(LineStyle strokeLineStyle);
               public void setPointStrokeLineStyleSet(boolean flag);
            public float getPointStrokeOpacity();
               public boolean isPointStrokeOpacitySet();
               public void setPointStrokeOpacity(float opacity);
               public void setPointStrokeOpacitySet(boolean flag);
          public float getPointStrokeWidth();
               public boolean isPointStrokeWidthSet();
               public void setPointStrokeWidth(float width);
               public void setPointStrokeWidthSet(boolean flag);
}
package org.opengis.go.display.style;
import java.awt.Color;
public interface PolygonSymbolizer {
                                public static final String POLYGON_FILL_BACKGROUND_COLOR = "POLYGON_FILL_BACKGROUND_COLOR";
    public static final String POLYGON_FILL_COLOR = "POLYGON_FILL_COLOR";
    public static final String POLYGON_FILL_GRADIENT_POINTS = "POLYGON_FILL_GRADIENT_POINTS";
     public static final String POLYGON_FILL_OPACITY = "POLYGON_FILL_OPACITY";
    public static final String POLYGON_FILL_PATTERN = "POLYGON_FILL_PATTERN";
    public static final String POLYGON_FILL_STYLE = "POLYGON_FILL_STYLE";
    public static final String POLYGON_STROKE_BEGIN_ARROW_STYLE = "POLYGON_STROKE_BEGIN_ARROW_STYLE";
    public static final String POLYGON_STROKE_END_ARROW_STYLE = "POLYGON_STROKE_END_ARROW_STYLE";
    public static final String POLYGON_STROKE_COLOR = "POLYGON_STROKE_COLOR";
     public static final String POLYGON_STROKE_DASH_ARRAY = "POLYGON_STROKE_DASH_ARRAY";
    public static final String POLYGON_STROKE_DASH_OFFSET = "POLYGON_STROKE_DASH_OFFSET";
    public static final String POLYGON_STROKE_FILL_BACKGROUND_COLOR = "POLYGON_STROKE_FILL_BACKGROUND_COLOR";
    public static final String POLYGON_STROKE_FILL_COLOR = "POLYGON_STROKE_FILL_COLOR";
    public static final String POLYGON_STROKE_FILL_GRADIENT_POINTS = "POLYGON_STROKE_FILL_GRADIENT_POINTS";
     public static final String POLYGON_STROKE_FILL_OPACITY = "POLYGON_STROKE_FILL_OPACITY";
    public static final String POLYGON_STROKE_FILL_PATTERN = "POLYGON_STROKE_FILL_PATTERN";
    public static final String POLYGON_STROKE_FILL_STYLE = "POLYGON_STROKE_FILL_STYLE";
    public static final String POLYGON_STROKE_LINE_CAP = "POLYGON_STROKE_LINE_CAP";
    public static final String POLYGON_STROKE_LINE_GAP = "POLYGON_STROKE_LINE_GAP";
    public static final String POLYGON_STROKE_LINE_JOIN = "POLYGON_STROKE_LINE_JOIN";
    public static final String POLYGON_STROKE_LINE_PATTERN = "POLYGON_STROKE_LINE_PATTERN";
    public static final String POLYGON_STROKE_LINE_STYLE = "POLYGON_STROKE_LINE_STYLE";
    public static final String POLYGON_STROKE_OPACITY = "POLYGON_STROKE_OPACITY";
    public static final String POLYGON_STROKE_WIDTH = "POLYGON_STROKE_WIDTH";
    public static final String POLYGON_STROKE_PATTERN = "POLYGON_STROKE_PATTERN";
                   public static final Color DEFAULT_POLYGON_FILL_BACKGROUND_COLOR = Color.BLACK;
       public static final Color DEFAULT_POLYGON_FILL_COLOR = Color.GRAY;
       public static final float[] DEFAULT_POLYGON_FILL_GRADIENT_POINTS = new float[2];
       public static final float DEFAULT_POLYGON_FILL_OPACITY = 1.f;
       public static final FillPattern DEFAULT_POLYGON_FILL_PATTERN = FillPattern.NONE;
       public static final FillStyle DEFAULT_POLYGON_FILL_STYLE = FillStyle.SOLID;
        public static final ArrowStyle DEFAULT_POLYGON_STROKE_BEGIN_ARROW_STYLE = ArrowStyle.NONE;
        public static final ArrowStyle DEFAULT_POLYGON_STROKE_END_ARROW_STYLE = ArrowStyle.NONE;
           public static final Color DEFAULT_POLYGON_STROKE_COLOR = Color.BLACK;
              public static final DashArray DEFAULT_POLYGON_STROKE_DASH_ARRAY = DashArray.NONE;
                   public static final float DEFAULT_POLYGON_STROKE_DASH_OFFSET = 0.f;
           public static final Color DEFAULT_POLYGON_STROKE_FILL_BACKGROUND_COLOR = Color.BLACK;
       public static final Color DEFAULT_POLYGON_STROKE_FILL_COLOR = Color.GRAY;
       public static final float[] DEFAULT_POLYGON_STROKE_FILL_GRADIENT_POINTS = new float[2];
       public static final float DEFAULT_POLYGON_STROKE_FILL_OPACITY = 1.f;
       public static final FillPattern DEFAULT_POLYGON_STROKE_FILL_PATTERN = FillPattern.NONE;
       public static final FillStyle DEFAULT_POLYGON_STROKE_FILL_STYLE = FillStyle.SOLID;
               public static final LineCap DEFAULT_POLYGON_STROKE_LINE_CAP = LineCap.BUTT;
                   public static final float DEFAULT_POLYGON_STROKE_LINE_GAP = 10.f;
               public static final LineJoin DEFAULT_POLYGON_STROKE_LINE_JOIN = LineJoin.BEVEL;
        public static final LinePattern DEFAULT_POLYGON_STROKE_LINE_PATTERN = LinePattern.NONE;
                   public static final LineStyle DEFAULT_POLYGON_STROKE_LINE_STYLE = LineStyle.SINGLE;
                   public static final float DEFAULT_POLYGON_STROKE_OPACITY = 1.f;
                  public static final float DEFAULT_POLYGON_STROKE_WIDTH = 1.f;
                               public Color getPolygonFillColor();
           public boolean isPolygonFillColorSet();
           public void setPolygonFillColor(Color fillColor);
           public void setPolygonFillColorSet(boolean flag);
          public Color getPolygonFillBackgroundColor();
           public boolean isPolygonFillBackgroundColorSet();
           public void setPolygonFillBackgroundColor(Color fillBackgroundColor);
           public void setPolygonFillBackgroundColorSet(boolean flag);
       public float[] getPolygonFillGradientPoints();
           public boolean isPolygonFillGradientPointsSet();
           public void setPolygonFillGradientPoints(float[] fillGradientPoints);
           public void setPolygonFillGradientPointsSet(boolean flag);
          public float getPolygonFillOpacity();
           public boolean isPolygonFillOpacitySet();
           public void setPolygonFillOpacity(float fillOpacity);
           public void setPolygonFillOpacitySet(boolean flag);
          public FillPattern getPolygonFillPattern();
           public boolean isPolygonFillPatternSet();
           public void setPolygonFillPattern(FillPattern fillPattern);
           public void setPolygonFillPatternSet(boolean flag);
          public FillStyle getPolygonFillStyle();
           public boolean isPolygonFillStyleSet();
           public void setPolygonFillStyle(FillStyle fillStyle);
           public void setPolygonFillStyleSet(boolean flag);
           public ArrowStyle getPolygonStrokeBeginArrowStyle();
               public boolean isPolygonStrokeBeginArrowStyleSet();
               public void setPolygonStrokeBeginArrowStyle(ArrowStyle strokeArrowStyle);
               public void setPolygonStrokeBeginArrowStyleSet(boolean flag);
           public ArrowStyle getPolygonStrokeEndArrowStyle();
               public boolean isPolygonStrokeEndArrowStyleSet();
               public void setPolygonStrokeEndArrowStyle(ArrowStyle strokeArrowStyle);
               public void setPolygonStrokeEndArrowStyleSet(boolean flag);
             public Color getPolygonStrokeColor();
               public boolean isPolygonStrokeColorSet();
               public void setPolygonStrokeColor(Color strokeColor);
               public void setPolygonStrokeColorSet(boolean flag);
          public DashArray getPolygonStrokeDashArray();
               public boolean isPolygonStrokeDashArraySet();
               public void setPolygonStrokeDashArray(DashArray strokeDashArray);
               public void setPolygonStrokeDashArraySet(boolean flag);
          public float getPolygonStrokeDashOffset();
               public boolean isPolygonStrokeDashOffsetSet();
               public void setPolygonStrokeDashOffset(float strokeDashOffset);
               public void setPolygonStrokeDashOffsetSet(boolean flag);
          public Color getPolygonStrokeFillColor();
           public boolean isPolygonStrokeFillColorSet();
           public void setPolygonStrokeFillColor(Color fillColor);
           public void setPolygonStrokeFillColorSet(boolean flag);
          public Color getPolygonStrokeFillBackgroundColor();
           public boolean isPolygonStrokeFillBackgroundColorSet();
           public void setPolygonStrokeFillBackgroundColor(Color fillBackgroundColor);
           public void setPolygonStrokeFillBackgroundColorSet(boolean flag);
       public float[] getPolygonStrokeFillGradientPoints();
           public boolean isPolygonStrokeFillGradientPointsSet();
           public void setPolygonStrokeFillGradientPoints(float[] fillGradientPoints);
           public void setPolygonStrokeFillGradientPointsSet(boolean flag);
          public float getPolygonStrokeFillOpacity();
           public boolean isPolygonStrokeFillOpacitySet();
           public void setPolygonStrokeFillOpacity(float fillOpacity);
           public void setPolygonStrokeFillOpacitySet(boolean flag);
          public FillPattern getPolygonStrokeFillPattern();
           public boolean isPolygonStrokeFillPatternSet();
           public void setPolygonStrokeFillPattern(FillPattern fillPattern);
           public void setPolygonStrokeFillPatternSet(boolean flag);
          public FillStyle getPolygonStrokeFillStyle();
           public boolean isPolygonStrokeFillStyleSet();
           public void setPolygonStrokeFillStyle(FillStyle fillStyle);
           public void setPolygonStrokeFillStyleSet(boolean flag);
             public LineCap getPolygonStrokeLineCap();
               public boolean isPolygonStrokeLineCapSet();
               public void setPolygonStrokeLineCap(LineCap strokeLineCap);
               public void setPolygonStrokeLineCapSet(boolean flag);
          public float getPolygonStrokeLineGap();
               public boolean isPolygonStrokeLineGapSet();
               public void setPolygonStrokeLineGap(float strokeLineGap);
               public void setPolygonStrokeLineGapSet(boolean flag);
            public LineJoin getPolygonStrokeLineJoin();
               public boolean isPolygonStrokeLineJoinSet();
               public void setPolygonStrokeLineJoin(LineJoin strokeLineJoin);
               public void setPolygonStrokeLineJoinSet(boolean flag);
            public LinePattern getPolygonStrokeLinePattern();
           public boolean isPolygonStrokeLinePatternSet();
           public void setPolygonStrokeLinePattern(LinePattern strokeLinePattern);
           public void setPolygonStrokeLinePatternSet(boolean flag);
             public LineStyle getPolygonStrokeLineStyle();
               public boolean isPolygonStrokeLineStyleSet();
               public void setPolygonStrokeLineStyle(LineStyle strokeLineStyle);
               public void setPolygonStrokeLineStyleSet(boolean flag);
            public float getPolygonStrokeOpacity();
               public boolean isPolygonStrokeOpacitySet();
               public void setPolygonStrokeOpacity(float opacity);
               public void setPolygonStrokeOpacitySet(boolean flag);
          public float getPolygonStrokeWidth();
               public boolean isPolygonStrokeWidthSet();
               public void setPolygonStrokeWidth(float width);
               public void setPolygonStrokeWidthSet(boolean flag);
    }
package org.opengis.go.display.style;
import java.awt.Color;
public interface Stroke {
       public static final String ARROW_DIRECTION = "STROKE_ARROW_DIRECTION";
             public static final String ARROW_STYLE = "STROKE_ARROW_STYLE";
          public static final String COLOR = "STROKE_COLOR";
         public static final String DASH_ARRAY = "STROKE_DASH_ARRAY";
          public static final String DASH_OFFSET = "STROKE_DASH_OFFSET";
          public static final String FILL = "STROKE_FILL";
          public static final String LINE_CAP = "STROKE_LINE_CAP";
          public static final String LINE_GAP = "STROKE_LINE_GAP";
          public static final String LINE_JOIN = "STROKE_LINE_JOIN";
       public static final String LINE_STYLE = "STROKE_LINE_STYLE";
           public static final String OPACITY = "STROKE_OPACITY";
           public static final String WIDTH = "STROKE_WIDTH";
           public ArrowStyle getBeginArrowStyle();
               public boolean isBeginArrowStyleSet();
               public void setBeginArrowStyle(ArrowStyle strokeArrowStyle);
               public void setBeginArrowStyleSet(boolean flag);
           public ArrowStyle getEndArrowStyle();
           public boolean isEndArrowStyleSet();
           public void setEndArrowStyle(ArrowStyle strokeArrowStyle);
           public void setEndArrowStyleSet(boolean flag);
             public Color getColor();
               public boolean isColorSet();
               public void setColor(Color strokeColor);
               public void setColorSet(boolean flag);
          public DashArray getDashArray();
               public boolean isDashArraySet();
               public void setDashArray(DashArray strokeDashArray);
               public void setDashArraySet(boolean flag);
          public float getDashOffset();
               public boolean isDashOffsetSet();
               public void setDashOffset(float strokeDashOffset);
               public void setDashOffsetSet(boolean flag);
          public Fill getFill();
               public boolean isFillSet();
               public void setFill(Fill strokeFill);
               public void setFillSet(boolean flag);
          public LineCap getLineCap();
               public boolean isLineCapSet();
               public void setLineCap(LineCap strokeLineCap);
               public void setLineCapSet(boolean flag);
          public float getLineGap();
               public boolean isLineGapSet();
               public void setLineGap(float strokeLineGap);
               public void setLineGapSet(boolean flag);
            public LineJoin getLineJoin();
               public boolean isLineJoinSet();
               public void setLineJoin(LineJoin strokeLineJoin);
               public void setLineJoinSet(boolean flag);
            public LineStyle getLineStyle();
               public boolean isLineStyleSet();
               public void setLineStyle(LineStyle strokeLineStyle);
               public void setLineStyleSet(boolean flag);
            public float getOpacity();
               public boolean isOpacitySet();
               public void setOpacity(float opacity);
               public void setOpacitySet(boolean flag);
          public float getWidth();
               public boolean isWidthSet();
               public void setWidth(float width);
               public void setWidthSet(boolean flag);
}
package org.opengis.go.display.style;
public interface Symbology {
               public int getSymbologyPropertyCount(SymbologyInfo info);
           public String[] getSymbologyPropertyNames(SymbologyInfo info);
           public Class getSymbologyPropertyType(SymbologyInfo info, String propertyName);
           public Object getSymbologyProperty(SymbologyInfo info, String propertyName) throws IllegalArgumentException;
           public void setSymbologyProperty(SymbologyInfo info, String propertyName, Object value)        throws IllegalArgumentException;
           public SymbologyInfo getActiveSymbology();
           public void setActiveSymbology(SymbologyInfo info) throws IllegalArgumentException;
}
package org.opengis.go.display.style;
public interface SymbologyInfo {
            public String getSymbologyName();
        public String getSymbologyVersion();
}
package org.opengis.go.display.style;
import java.awt.Color;
import java.awt.Font;
public interface TextSymbolizer {
                                public static final String TEXT_FILL_BACKGROUND_COLOR = "TEXT_FILL_BACKGROUND_COLOR";
    public static final String TEXT_FILL_COLOR = "TEXT_FILL_COLOR";
    public static final String TEXT_FILL_GRADIENT_POINTS = "TEXT_FILL_GRADIENT_POINTS";
     public static final String TEXT_FILL_OPACITY = "TEXT_FILL_OPACITY";
    public static final String TEXT_FILL_PATTERN = "TEXT_FILL_PATTERN";
    public static final String TEXT_FILL_STYLE = "TEXT_FILL_STYLE";
    public static final String TEXT_FONT = "TEXT_FONT";
    public static final String TEXT_HALO_RADIUS = "TEXT_HALO_RADIUS";
    public static final String TEXT_LABEL = "TEXT_LABEL";
     public static final String TEXT_LABEL_ROTATION = "TEXT_ROTATION";
    public static final String TEXT_LABEL_SHOW_LABEL = "TEXT_SHOW_LABEL";
    public static final String TEXT_LABEL_X_ANCHOR = "TEXT_X_ANCHOR";
    public static final String TEXT_LABEL_Y_ANCHOR = "TEXT_Y_ANCHOR";
    public static final String TEXT_LABEL_X_DISPLACEMENT = "TEXT_X_DISPLACEMENT";
    public static final String TEXT_LABEL_Y_DISPLACEMENT = "TEXT_Y_DISPLACEMENT";
                       public static final Color DEFAULT_TEXT_FILL_COLOR = Color.BLACK;
       public static final Color DEFAULT_TEXT_FILL_BACKGROUND_COLOR = Color.WHITE;
       public static final float[] DEFAULT_TEXT_FILL_GRADIENT_POINTS = new float[2];
       public static final float DEFAULT_TEXT_FILL_OPACITY = 1.f;
       public static final FillPattern DEFAULT_TEXT_FILL_PATTERN = FillPattern.NONE;
       public static final FillStyle DEFAULT_TEXT_FILL_STYLE = FillStyle.SOLID;
            public static final Font DEFAULT_TEXT_FONT = null;
           public static final float DEFAULT_TEXT_HALO_RADIUS = 1.f;
           public static final String DEFAULT_TEXT_LABEL = "Label";
           public static final float DEFAULT_TEXT_LABEL_ROTATION = 0f;
               public static final boolean DEFAULT_TEXT_LABEL_SHOW_LABEL = false;
           public static final XAnchor DEFAULT_TEXT_LABEL_X_ANCHOR = XAnchor.CENTER;
           public static final float DEFAULT_TEXT_LABEL_X_DISPLACEMENT = 0f;
           public static final YAnchor DEFAULT_TEXT_LABEL_Y_ANCHOR = YAnchor.MIDDLE;
           public static final float DEFAULT_TEXT_LABEL_Y_DISPLACEMENT = 0f;
                           public Color getTextFillColor();
           public boolean isTextFillColorSet();
           public void setTextFillColor(Color fillColor);
           public void setTextFillColorSet(boolean flag);
          public Color getTextFillBackgroundColor();
           public boolean isTextFillBackgroundColorSet();
           public void setTextFillBackgroundColor(Color fillBackgroundColor);
           public void setTextFillBackgroundColorSet(boolean flag);
       public float[] getTextFillGradientPoints();
           public boolean isTextFillGradientPointsSet();
           public void setTextFillGradientPoints(float[] fillGradientPoints);
           public void setTextFillGradientPointsSet(boolean flag);
          public float getTextFillOpacity();
           public boolean isTextFillOpacitySet();
           public void setTextFillOpacity(float fillOpacity);
           public void setTextFillOpacitySet(boolean flag);
          public FillPattern getTextFillPattern();
           public boolean isTextFillPatternSet();
           public void setTextFillPattern(FillPattern fillPattern);
           public void setTextFillPatternSet(boolean flag);
          public FillStyle getTextFillStyle();
           public boolean isTextFillStyleSet();
           public void setTextFillStyle(FillStyle fillStyle);
           public void setTextFillStyleSet(boolean flag);
                               public Font getTextFont();
               public boolean isTextFontSet();
               public void setTextFont(Font object);
               public void setTextFontSet(boolean flag);
                   public float getTextHaloRadius();
               public boolean isTextHaloRadiusSet();
               public void setTextHaloRadius(float haloRadius);
               public void setTextHaloRadiusSet(boolean flag);
           public String getTextLabel();
               public boolean isTextLabelSet();
               public void setTextLabel(String label);
               public void setTextLabelSet(boolean flag);
           public float getTextLabelRotation();
               public boolean isTextLabelRotationSet();
               public void setTextLabelRotation(float labelRotation);
               public void setTextLabelRotationSet(boolean flag);
          public boolean getTextLabelShowLabel();
               public boolean isTextLabelShowLabelSet();
               public void setTextLabelShowLabel(boolean showLabel);
               public void setTextLabelShowLabelSet(boolean flag);
       public XAnchor getTextLabelXAnchor();
               public boolean isTextLabelXAnchorSet();
               public void setTextLabelXAnchor(XAnchor labelXAnchor);
               public void setTextLabelXAnchorSet(boolean flag);
          public float getTextLabelXDisplacement();
               public boolean isTextLabelXDisplacementSet();
               public void setTextLabelXDisplacement(float labelXDisplacement);
               public void setTextLabelXDisplacementSet(boolean flag);
          public YAnchor getTextLabelYAnchor();
               public boolean isTextLabelYAnchorSet();
               public void setTextLabelYAnchor(YAnchor labelYAnchor);
               public void setTextLabelYAnchorSet(boolean flag);
          public float getTextLabelYDisplacement();
               public boolean isTextLabelYDisplacementSet();
               public void setTextLabelYDisplacement(float labelYDisplacement);
               public void setTextLabelYDisplacementSet(boolean flag);
               }
package org.opengis.go.display.style;
public interface Viewability {
                             public static final String VIEWABILITY_MAX_SCALE = "VIEWABILITY_MAX_SCALE";
        public static final String VIEWABILITY_MIN_SCALE = "VIEWABILITY_MIN_SCALE";
        public static final String VIEWABILITY_VISIBLE = "VIEWABILITY_VISIBLE";
        public static final String VIEWABILITY_Z_ORDER = "VIEWABILITY_Z_ORDER";
               public static final int DEFAULT_VIEWABILITY_MAX_SCALE = Integer.MAX_VALUE;
       public static final int DEFAULT_VIEWABILITY_MIN_SCALE = 1;
           public static final boolean DEFAULT_VIEWABILITY_VISIBLE = true;
       public static final double DEFAULT_VIEWABILITY_Z_ORDER = 0.0;
                           public double getViewabilityMaxScale();
               public boolean isViewabilityMaxScaleSet();
               public void setViewabilityMaxScale(double maxScale);
               public void setViewabilityMaxScaleSet(boolean flag);
         public double getViewabilityMinScale();
               public boolean isViewabilityMinScaleSet();
               public void setViewabilityMinScale(double minScale);
               public void setViewabilityMinScaleSet(boolean flag);
           public double getViewabilityZOrderHint();
               public boolean isViewabilityZOrderHintSet();
               public void setViewabilityZOrderHint(double zOrderHint);
               public void setViewabilityZOrderHintSet(boolean flag);
           public boolean getViewabilityVisible();
               public boolean isViewabilityVisibleSet();
               public void setViewabilityVisible(boolean visible);
               public void setViewabilityVisibleSet(boolean flag);
    }
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class XAnchor extends SimpleEnumerationType {
                       private static final List VALUES = new ArrayList(3);
           public static final XAnchor LEFT = new XAnchor("LEFT", "");
           public static final XAnchor CENTER = new XAnchor("CENTER", "");
           public static final XAnchor RIGHT = new XAnchor("RIGHT", "");
                           protected XAnchor(String name, String description) {
        super(VALUES, name, description);
    }
                   public static XAnchor[] values() {
        synchronized (VALUES) {
            return (XAnchor[]) VALUES.toArray(new XAnchor[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go.display.style;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class YAnchor extends SimpleEnumerationType {
                       private static final List VALUES = new ArrayList(4);
           public static final YAnchor TOP = new YAnchor("Top", "");
           public static final YAnchor MIDDLE = new YAnchor("Middle", "");
           public static final YAnchor BASELINE = new YAnchor("Baseline", "");
           public static final YAnchor BOTTOM = new YAnchor("Bottom", "");
           private static int next_value = 0;
                           private static synchronized int nextValue() {
        return next_value++;
    }
           public static int getNumberOfStyles() {
        return next_value;
    }
                           protected YAnchor(String name, String description) {
        super(VALUES, name, description);
    }
                   public static YAnchor[] values() {
        synchronized (VALUES) {
            return (YAnchor[]) VALUES.toArray(new YAnchor[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.go.geometry;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface BoundingPolygon extends Bounds {
           public DirectPosition[] getVertices();
           public void setVertices(DirectPosition[] vertices);
}
package org.opengis.go.geometry;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface BoundingRectangle extends Bounds {
       public void setTopLeft(DirectPosition coord);
       public DirectPosition getTopLeft();
       public void setBottomRight(DirectPosition coord);
       public DirectPosition getBottomRight();
       public BoundingRectangle getIntersection(BoundingRectangle bounds, BoundingRectangle result);
       public BoundingRectangle getCombinedExtent(BoundingRectangle bounds, BoundingRectangle result);
}
package org.opengis.go.geometry;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface Bounds {
       public boolean isValid();
       public void setValid(boolean newValue);
       public boolean contains(DirectPosition location);
       public void expandToInclude(DirectPosition location);
       public CoordinateReferenceSystem getCoordinateReferenceSystem();
       public void setCoordinateReferenceSystem(CoordinateReferenceSystem crs);
}
package org.opengis.go.geometry;
public interface BoundsFactory {
           public Bounds createBounds(Class boundsInterface);
}
package org.opengis.go.spatial;
public class GlobalPathType extends PathType {
                    protected GlobalPathType (String name, String description) {
        super(name, description);
    }
        public static final GlobalPathType GREAT_CIRCLE_ELLIPSOIDAL =        new GlobalPathType("GREAT_CIRCLE_ELLIPSOIDAL",            "The path that is the shortest distance path over the WGS84 ellipsoid.");
                public static final GlobalPathType GREAT_CIRCLE_SPHERICAL =        new GlobalPathType("GREAT_CIRCLE_SPHERICAL",            "The path that is the shortest distance path over the sphere whose radius is the equatorial radius of the WGS84 ellipsoid.");
        public static final GlobalPathType RHUMBLINE_ELLIPSOIDAL =        new GlobalPathType("RHUMBLINE_ELLIPSOIDAL",            "The path that is the path of constant bearing over the WGS84 ellipsoid.");
        public static final GlobalPathType RHUMBLINE_SPHERICAL =        new GlobalPathType("RHUMBLINE_SPHERICAL",            "The path that is the path of constant bearing over the sphere whose radius is the equatorial radius of the WGS84 ellipsoid.");
                                                       private static final GlobalPathType[] enumList =        {
            GREAT_CIRCLE_ELLIPSOIDAL,            GREAT_CIRCLE_SPHERICAL,            RHUMBLINE_ELLIPSOIDAL,            RHUMBLINE_SPHERICAL }
;
  }
package org.opengis.go.spatial;
import java.util.ArrayList;
import java.util.List;
import org.opengis.util.CodeList;
import org.opengis.util.SimpleEnumerationType;
public class PathType extends SimpleEnumerationType {
       protected static final List VALUES = new ArrayList();
               protected PathType(String name, String description) {
        super(VALUES, name, description);
                   }
               public static PathType[] values() {
        synchronized (VALUES) {
            return (PathType[]) VALUES.toArray(new PathType[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
   }
package org.opengis.go.spatial;
public class UnprojectedPathType extends PathType {
       protected UnprojectedPathType(String name, String description) {
        super(name, description);
    }
        public static final UnprojectedPathType PIXEL_STRAIGHT =        new UnprojectedPathType("PIXEL_STRAIGHT",            "The path that is drawn as screen-straight, regardless of any current projection.");
                public static final UnprojectedPathType CONTINUOUS_SPLINE =        new UnprojectedPathType("CONTINUOUS_SPLINE",            "The path that connects its points via a continuous (although not necessarily smooth) spline.");
                        }
package org.opengis.go.spatial;
public class VectorPathType extends PathType {
           protected VectorPathType(String name, String description) {
        super(name, description);
    }
        public static final VectorPathType VECTOR =        new VectorPathType("VECTOR", "The path that is the Euclidean shortest distance path.");
    }
package org.opengis.metadata.citation;
public interface Address {
}
package org.opengis.metadata.citation;
import java.util.Locale;
public interface Citation {
       String getTitle(Locale locale);
       String[] getAlternateTitles(Locale locale);
}
package org.opengis.metadata.citation;
public interface Contact {
}
package org.opengis.metadata.citation;
public interface OnLineResource {
}
package org.opengis.metadata.citation;
public interface ResponsibleParty {
}
package org.opengis.metadata.citation;
public interface Series {
}
package org.opengis.metadata.citation;
public interface Telephone {
}
package org.opengis.metadata.extent;
import org.opengis.spatialschema.geometry.Geometry;
public interface BoundingPolygon extends GeographicExtent {
       public Geometry getPolygon();
}
package org.opengis.metadata.extent;
import java.util.Locale;
public interface Extent {
       public String getDescription(Locale locale);
       public GeographicExtent getGeographicElement();
       public TemporalExtent getTemporalElement();
       public VerticalExtent getVerticalElement();
}
package org.opengis.metadata.extent;
public interface GeographicBoundingBox extends GeographicExtent {
       public double getWestBoundLongitude();
       public double getEastBoundLongitude();
       public double getSouthBoundLatitude();
       public double getNorthBoundLatitude();
}
package org.opengis.metadata.extent;
import org.opengis.referencing.Identifier;
public interface GeographicDescription extends GeographicExtent {
       public Identifier getGeographicIdentifier();
}
package org.opengis.metadata.extent;
public interface GeographicExtent {
       public boolean isInclusion();
}
package org.opengis.metadata.extent;
public interface SpatialTemporalExtent extends TemporalExtent {
       public GeographicExtent[] getSpatialExtent();
}
package org.opengis.metadata.extent;
import java.util.Date;
public interface TemporalExtent {
       public Date getStartTime();
       public Date getEndTime();
}
package org.opengis.metadata.extent;
import javax.units.Unit;
import org.opengis.referencing.datum.VerticalDatum;
public interface VerticalExtent {
       public double getMinimumValue();
       public double getMaximumValue();
       public Unit getUnit();
       public VerticalDatum getVerticalDatum();
}
package org.opengis.parameter;
import org.opengis.referencing.Info;
public interface GeneralOperationParameter extends Info {
       GeneralParameterValue createValue();
       int getMinimumOccurs();
       int getMaximumOccurs();
}
package org.opengis.parameter;
import org.opengis.util.Cloneable;
public interface GeneralParameterValue extends Cloneable {
       GeneralOperationParameter getDescriptor();
       Object clone();
}
package org.opengis.parameter;
public class InvalidParameterNameException extends IllegalArgumentException {
       private static final long serialVersionUID = -8473266898408204803L;
       private final String parameterName;
       public InvalidParameterNameException(String message, String parameterName) {
        super(message);
        this.parameterName = parameterName;
    }
       public String getParameterName() {
        return parameterName;
    }
}
package org.opengis.parameter;
public class InvalidParameterTypeException extends IllegalStateException {
       private static final long serialVersionUID = 2740762597003093176L;
       private final String parameterName;
       public InvalidParameterTypeException(String message, String parameterName) {
        super(message);
        this.parameterName = parameterName;
    }
       public String getParameterName() {
        return parameterName;
    }
}
package org.opengis.parameter;
public class InvalidParameterValueException extends IllegalArgumentException {
       private static final long serialVersionUID = 3814037056147642789L;
       private final String parameterName;
       private final Object value;
       public InvalidParameterValueException(String message, String parameterName, Object value) {
        super(message);
        this.parameterName = parameterName;
        this.value = value;
    }
       public InvalidParameterValueException(String message, String parameterName, double value) {
        this(message, parameterName, new Double(value));
    }
       public InvalidParameterValueException(String message, String parameterName, int value) {
        this(message, parameterName, new Integer(value));
    }
       public String getParameterName() {
        return parameterName;
    }
       public Object getValue() {
        return value;
    }
}
package org.opengis.parameter;
import java.util.Set;
import javax.units.Unit;
public interface OperationParameter extends GeneralOperationParameter {
          Class getValueClass();
       Set getValidValues();
       Object getDefaultValue();
       Comparable getMinimumValue();
       Comparable getMaximumValue();
       Unit getUnit();
}
package org.opengis.parameter;
public interface OperationParameterGroup extends GeneralOperationParameter {
          GeneralOperationParameter[] getParameters();
       GeneralOperationParameter getParameter(String name) throws ParameterNotFoundException;
}
package org.opengis.parameter;
public class ParameterNotFoundException extends IllegalArgumentException {
       private static final long serialVersionUID = -8074834945993975175L;
       private final String parameterName;
       public ParameterNotFoundException(String message, String parameterName) {
        super(message);
        this.parameterName = parameterName;
    }
       public String getParameterName() {
        return parameterName;
    }
}
package org.opengis.parameter;
import java.net.URL;
import javax.units.Unit;
public interface ParameterValue extends GeneralParameterValue {
          Unit getUnit();
       double doubleValue(Unit unit) throws InvalidParameterTypeException;
       double doubleValue() throws InvalidParameterTypeException;
       int intValue() throws InvalidParameterTypeException;
       boolean booleanValue() throws InvalidParameterTypeException;
       String stringValue() throws InvalidParameterTypeException;
       double[] doubleValueList(final Unit unit) throws InvalidParameterTypeException;
       double[] doubleValueList() throws InvalidParameterTypeException;
       int[] intValueList() throws InvalidParameterTypeException;
       URL valueFile() throws InvalidParameterTypeException;
       Object getValue();
       void setValue(double[] values, Unit unit) throws InvalidParameterValueException;
       void setValue(double value, Unit unit) throws InvalidParameterValueException;
       void setValue(double value) throws InvalidParameterValueException;
       void setValue(int value) throws InvalidParameterValueException;
       void setValue(boolean value) throws InvalidParameterValueException;
       void setValue(Object value) throws InvalidParameterValueException;
       Object clone();
}
package org.opengis.parameter;
public interface ParameterValueGroup extends GeneralParameterValue {
          GeneralParameterValue[] getValues();
       GeneralParameterValue getValue(String name) throws ParameterNotFoundException;
       Object clone();
}
package org.opengis.referencing;
import java.util.Locale;
import java.util.Set;
import org.opengis.metadata.citation.Citation;
public interface AuthorityFactory {
       Factory getFactory();
       Citation getAuthority();
       Set getAuthorityCodes(Class type) throws FactoryException;
       String getDescriptionText(String code, Locale locale) throws FactoryException;
       Object createObject(String code) throws FactoryException;
}
package org.opengis.referencing.crs;
public interface CompoundCRS extends CoordinateReferenceSystem {
       CoordinateReferenceSystem[] getCoordinateReferenceSystems();
}
package org.opengis.referencing.crs;
import org.opengis.referencing.ReferenceSystem;
import org.opengis.referencing.cs.CoordinateSystem;
import org.opengis.referencing.datum.Datum;
public interface CoordinateReferenceSystem extends ReferenceSystem {
       CoordinateSystem getCoordinateSystem();
       Datum getDatum();
}
package org.opengis.referencing.crs;
import org.opengis.referencing.AuthorityFactory;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.NoSuchAuthorityCodeException;
  public interface CRSAuthorityFactory extends AuthorityFactory {
       CoordinateReferenceSystem createCoordinateReferenceSystem(String code) throws FactoryException;
       CompoundCRS createCompoundCRS(String code) throws FactoryException;
       DerivedCRS createDerivedCRS(String code) throws FactoryException;
                   EngineeringCRS createEngineeringCRS(String code) throws FactoryException;
       GeographicCRS createGeographicCRS(String code) throws FactoryException;
       GeocentricCRS createGeocentricCRS(String code) throws FactoryException;
       ImageCRS createImageCRS(String code) throws FactoryException;
       ProjectedCRS createProjectedCRS(String code) throws FactoryException;
       TemporalCRS createTemporalCRS(String code) throws FactoryException;
       VerticalCRS createVerticalCRS(String code) throws FactoryException;
}
package org.opengis.referencing.crs;
import java.util.Map;
import org.opengis.referencing.Factory;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.cs.CartesianCS;
import org.opengis.referencing.cs.SphericalCS;
import org.opengis.referencing.cs.EllipsoidalCS;
import org.opengis.referencing.cs.VerticalCS;
import org.opengis.referencing.cs.TemporalCS;
import org.opengis.referencing.cs.CoordinateSystem;
import org.opengis.referencing.datum.EngineeringDatum;
import org.opengis.referencing.datum.GeodeticDatum;
import org.opengis.referencing.datum.ImageDatum;
import org.opengis.referencing.datum.TemporalDatum;
import org.opengis.referencing.datum.VerticalDatum;
import org.opengis.referencing.operation.Conversion;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.parameter.GeneralParameterValue;
public interface CRSFactory extends Factory {
       CompoundCRS createCompoundCRS(Map                       properties,                                  CoordinateReferenceSystem[] elements) throws FactoryException;
       EngineeringCRS createEngineeringCRS(Map         properties,                                        EngineeringDatum datum,                                        CoordinateSystem    cs) throws FactoryException;
       GeocentricCRS createGeocentricCRS(Map      properties,                                      GeodeticDatum datum,                                      CartesianCS      cs) throws FactoryException;
       GeocentricCRS createGeocentricCRS(Map      properties,                                      GeodeticDatum datum,                                      SphericalCS      cs) throws FactoryException;
       GeographicCRS createGeographicCRS(Map      properties,                                      GeodeticDatum datum,                                      EllipsoidalCS    cs) throws FactoryException;
           ImageCRS createImageCRS(Map      properties,                            ImageDatum    datum,                            CoordinateSystem cs) throws FactoryException;
       DerivedCRS createDerivedCRS(Map                 properties,                                CoordinateReferenceSystem base,                                MathTransform    baseToDerived,                                CoordinateSystem     derivedCS) throws FactoryException;
           ProjectedCRS createProjectedCRS(Map            properties,                                    GeographicCRS      geoCRS,                                    MathTransform toProjected,                                    CartesianCS            cs) throws FactoryException;
       ProjectedCRS createProjectedCRS(Map                          properties,                                    GeographicCRS                    geoCRS,                                    String                   projectionName,                                    GeneralParameterValue[] parameterValues,                                    CartesianCS                          cs) throws FactoryException;
       TemporalCRS createTemporalCRS(Map      properties,                                  TemporalDatum datum,                                  TemporalCS       cs) throws FactoryException;
       VerticalCRS createVerticalCRS(Map     properties,                                 VerticalDatum datum,                                 VerticalCS       cs) throws FactoryException;
       CoordinateReferenceSystem createFromXML(String xml) throws FactoryException;
       CoordinateReferenceSystem createFromWKT(String wkt) throws FactoryException;
}
package org.opengis.referencing.crs;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface DerivedCRS extends GeneralDerivedCRS {
}
package org.opengis.referencing.crs;
import org.opengis.referencing.datum.EngineeringDatum;
 public interface EngineeringCRS extends CoordinateReferenceSystem {
   }
package org.opengis.referencing.crs;
import org.opengis.referencing.operation.Conversion;
public interface GeneralDerivedCRS extends CoordinateReferenceSystem {
       CoordinateReferenceSystem getBaseCRS();
       Conversion getConversionFromBase();
}
package org.opengis.referencing.crs;
import org.opengis.referencing.cs.CartesianCS;
import org.opengis.referencing.cs.SphericalCS;
import org.opengis.referencing.cs.CoordinateSystem;
import org.opengis.referencing.datum.GeodeticDatum;
public interface GeocentricCRS extends CoordinateReferenceSystem {
       CoordinateSystem getCoordinateSystem();
            }
package org.opengis.referencing.crs;
import org.opengis.referencing.cs.EllipsoidalCS;
         import org.opengis.referencing.datum.GeodeticDatum;
public interface GeographicCRS extends CoordinateReferenceSystem {
                          }
package org.opengis.referencing.crs;
import org.opengis.referencing.cs.CartesianCS;
import org.opengis.referencing.cs.ObliqueCartesianCS;
import org.opengis.referencing.datum.ImageDatum;
 public interface ImageCRS extends CoordinateReferenceSystem {
               }
package org.opengis.referencing.crs;
import org.opengis.referencing.cs.CartesianCS;
import org.opengis.referencing.operation.Projection;
public interface ProjectedCRS extends GeneralDerivedCRS {
         }
package org.opengis.referencing.crs;
import org.opengis.referencing.cs.TemporalCS;
import org.opengis.referencing.datum.TemporalDatum;
public interface TemporalCRS extends CoordinateReferenceSystem {
                          }
package org.opengis.referencing.crs;
import org.opengis.referencing.cs.VerticalCS;
    import org.opengis.referencing.datum.VerticalDatum;
public interface VerticalCRS extends CoordinateReferenceSystem {
      }
package org.opengis.referencing.cs;
import java.util.List;
import java.util.ArrayList;
import org.opengis.util.CodeList;
public final class AxisDirection extends CodeList {
       private static final long serialVersionUID = -4405275475770755714L;
       private static final List VALUES = new ArrayList(13);
                       public static final AxisDirection OTHER = new AxisDirection("OTHER");
        public static final AxisDirection NORTH = new AxisDirection("NORTH");
        public static final AxisDirection SOUTH = new AxisDirection("SOUTH");
        public static final AxisDirection EAST = new AxisDirection("EAST");
        public static final AxisDirection WEST = new AxisDirection("WEST");
        public static final AxisDirection UP = new AxisDirection("UP");
        public static final AxisDirection DOWN = new AxisDirection("DOWN");
        public static final AxisDirection RIGHT = new AxisDirection("RIGHT");
        public static final AxisDirection LEFT = new AxisDirection("LEFT");
        public static final AxisDirection TOP = new AxisDirection("TOP");
        public static final AxisDirection BOTTOM = new AxisDirection("BOTTOM");
        public static final AxisDirection FUTURE = new AxisDirection("FUTURE");
        public static final AxisDirection PAST = new AxisDirection("PAST");
        private static final AxisDirection[] STANDARD_VALUES = values();
       public AxisDirection(final String name) {
        super(name, VALUES);
    }
       public static AxisDirection[] values() {
        synchronized (VALUES) {
            return (AxisDirection[]) VALUES.toArray(new AxisDirection[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
       public AxisDirection inverse() {
        final int value = ordinal()-1;
        if (value>=0 && value<STANDARD_VALUES.length-1) {
            return STANDARD_VALUES[(value ^ 1)+1];
        }
 else {
            return this;
        }
    }
       public AxisDirection absolute() {
        final int value = ordinal()-1;
        if (value>=0 && value<STANDARD_VALUES.length-1) {
            return STANDARD_VALUES[(value & ~1)+1];
        }
 else {
            return this;
        }
    }
}
package org.opengis.referencing.cs;
public interface CartesianCS extends ObliqueCartesianCS {
}
package org.opengis.referencing.cs;
import org.opengis.referencing.Info;
public interface CoordinateSystem extends Info {
       int getDimension();
       CoordinateSystemAxis getAxis(int dimension) throws IndexOutOfBoundsException;
}
package org.opengis.referencing.cs;
import javax.units.Unit;
import org.opengis.referencing.Info;
public interface CoordinateSystemAxis extends Info {
       String getAbbreviation();
       AxisDirection getDirection();
       Unit getUnit();
}
package org.opengis.referencing.cs;
import javax.units.Unit;
import org.opengis.referencing.AuthorityFactory;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.NoSuchAuthorityCodeException;
  public interface CSAuthorityFactory extends AuthorityFactory {
       CoordinateSystem createCoordinateSystem(String code) throws FactoryException;
       CartesianCS createCartesianCS(String code) throws FactoryException;
       PolarCS createPolarCS(String code) throws FactoryException;
       CylindricalCS createCylindricalCS(String code) throws FactoryException;
       SphericalCS createSphericalCS(String code) throws FactoryException;
       EllipsoidalCS createEllipsoidalCS(String code) throws FactoryException;
       VerticalCS createVerticalCS(String code) throws FactoryException;
       TemporalCS createTemporalCS(String code) throws FactoryException;
       CoordinateSystemAxis createCoordinateSystemAxis(String code) throws FactoryException;
       Unit createUnit(String code) throws FactoryException;
}
package org.opengis.referencing.cs;
import java.util.Map;
import javax.units.Unit;
import org.opengis.referencing.Factory;
import org.opengis.referencing.FactoryException;
public interface CSFactory extends Factory {
       CoordinateSystemAxis createCoordinateSystemAxis(Map           properties,                                                    String        abbreviation,                                                    AxisDirection direction,                                                    Unit          unit) throws FactoryException;
       CartesianCS createCartesianCS(Map             properties,                                  CoordinateSystemAxis axis0,                                  CoordinateSystemAxis axis1) throws FactoryException;
       CartesianCS createCartesianCS(Map             properties,                                  CoordinateSystemAxis axis0,                                  CoordinateSystemAxis axis1,                                  CoordinateSystemAxis axis2) throws FactoryException;
       PolarCS createPolarCS(Map             properties,                          CoordinateSystemAxis axis0,                          CoordinateSystemAxis axis1) throws FactoryException;
       CylindricalCS createCylindricalCS(Map            properties,                                      PolarCS           polarCS,                                      CoordinateSystemAxis axis) throws FactoryException;
       SphericalCS createSphericalCS(Map             properties,                                  CoordinateSystemAxis axis0,                                  CoordinateSystemAxis axis1,                                  CoordinateSystemAxis axis2) throws FactoryException;
       EllipsoidalCS createEllipsoidalCS(Map             properties,                                      CoordinateSystemAxis axis0,                                      CoordinateSystemAxis axis1) throws FactoryException;
       EllipsoidalCS createEllipsoidalCS(Map             properties,                                      CoordinateSystemAxis axis0,                                      CoordinateSystemAxis axis1,                                      CoordinateSystemAxis axis2) throws FactoryException;
       VerticalCS createVerticalCS(Map properties, CoordinateSystemAxis axis) throws FactoryException;
       TemporalCS createTemporalCS(Map properties, CoordinateSystemAxis axis) throws FactoryException;
}
package org.opengis.referencing.cs;
public interface CylindricalCS extends CoordinateSystem {
}
package org.opengis.referencing.cs;
public interface EllipsoidalCS extends CoordinateSystem {
}
package org.opengis.referencing.cs;
public interface LinearCS extends CoordinateSystem {
}
package org.opengis.referencing.cs;
public interface ObliqueCartesianCS extends CoordinateSystem {
}
package org.opengis.referencing.cs;
public interface PolarCS extends CoordinateSystem {
}
package org.opengis.referencing.cs;
public interface SphericalCS extends CoordinateSystem {
}
package org.opengis.referencing.cs;
public interface TemporalCS extends CoordinateSystem {
}
package org.opengis.referencing.cs;
public interface UserDefinedCS extends CoordinateSystem {
}
package org.opengis.referencing.cs;
public interface VerticalCS extends CoordinateSystem {
}
package org.opengis.referencing.datum;
import java.util.Date;
import java.util.Locale;
import org.opengis.referencing.Info;
import org.opengis.metadata.extent.Extent;
public interface Datum extends Info {
       String getAnchorPoint(Locale locale);
       Date getRealizationEpoch();
       Extent getValidArea();
       String getScope(Locale locale);
}
package org.opengis.referencing.datum;
import javax.units.Unit;
import org.opengis.referencing.AuthorityFactory;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.NoSuchAuthorityCodeException;
public interface DatumAuthorityFactory extends AuthorityFactory {
       Datum createDatum(String code) throws FactoryException;
       EngineeringDatum createEngineeringDatum(String code) throws FactoryException;
       ImageDatum createImageDatum(String code) throws FactoryException;
       VerticalDatum createVerticalDatum(String code) throws FactoryException;
       TemporalDatum createTemporalDatum(String code) throws FactoryException;
       GeodeticDatum createGeodeticDatum(String code) throws FactoryException;
       Ellipsoid createEllipsoid(String code) throws FactoryException;
       PrimeMeridian createPrimeMeridian(String code) throws FactoryException;
       String geoidFromWktName(String wkt);
       String wktFromGeoidName(String geoid);
}
package org.opengis.referencing.datum;
import java.util.Map;
import java.util.Date;
import javax.units.Unit;
import org.opengis.referencing.Factory;
import org.opengis.referencing.FactoryException;
public interface DatumFactory extends Factory {
       EngineeringDatum createEngineeringDatum(Map properties) throws FactoryException;
       GeodeticDatum createGeodeticDatum(Map           properties,                                      Ellipsoid     ellipsoid,                                      PrimeMeridian primeMeridian) throws FactoryException;
       ImageDatum createImageDatum(Map properties, PixelInCell pixelInCell) throws FactoryException;
       TemporalDatum createTemporalDatum(Map properties, Date origin) throws FactoryException;
       VerticalDatum createVerticalDatum(Map properties, VerticalDatumType type) throws FactoryException;
       Ellipsoid createEllipsoid(Map    properties,                              double semiMajorAxis,                              double semiMinorAxis,                              Unit   unit) throws FactoryException;
       Ellipsoid createFlattenedSphere(Map    properties,                                    double semiMajorAxis,                                    double inverseFlattening,                                    Unit   unit) throws FactoryException;
       PrimeMeridian createPrimeMeridian(Map    properties,                                      double longitude,                                      Unit   angularUnit) throws FactoryException;
}
package org.opengis.referencing.datum;
import javax.units.Unit;
import org.opengis.referencing.Info;
public interface Ellipsoid extends Info {
       Unit getAxisUnit();
       double getSemiMajorAxis();
       double getSemiMinorAxis();
       double getInverseFlattening();
       boolean isIvfDefinitive();
       boolean isSphere();
}
package org.opengis.referencing.datum;
public interface EngineeringDatum extends Datum {
}
package org.opengis.referencing.datum;
public interface GeodeticDatum extends Datum {
       Ellipsoid getEllipsoid();
       PrimeMeridian getPrimeMeridian();
}
package org.opengis.referencing.datum;
public interface ImageDatum extends Datum {
       PixelInCell getPixelInCell();
}
package org.opengis.referencing.datum;
import java.util.List;
import java.util.ArrayList;
import org.opengis.util.CodeList;
public final class PixelInCell extends CodeList {
       private static final long serialVersionUID = 2857889370030758462L;
       private static final List VALUES = new ArrayList(2);
       public static final PixelInCell CELL_CENTER = new PixelInCell("CELL_CENTER");
       public static final PixelInCell CELL_CORNER = new PixelInCell("CELL_CORNER");
       public PixelInCell(final String name) {
        super(name, VALUES);
    }
       public static PixelInCell[] values() {
        synchronized (VALUES) {
            return (PixelInCell[]) VALUES.toArray(new PixelInCell[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.referencing.datum;
import javax.units.Unit;
import org.opengis.referencing.Info;
public interface PrimeMeridian extends Info {
       double getGreenwichLongitude();
       Unit getAngularUnit();
}
package org.opengis.referencing.datum;
import java.util.Date;
import java.util.Locale;
public interface TemporalDatum extends Datum {
       Date getOrigin();
       String getAnchorPoint(Locale locale);
       Date getRealizationEpoch();
}
package org.opengis.referencing.datum;
public interface VerticalDatum extends Datum {
       VerticalDatumType getVerticalDatumType();
}
package org.opengis.referencing.datum;
import java.util.List;
import java.util.ArrayList;
import org.opengis.util.CodeList;
public final class VerticalDatumType extends CodeList {
       private static final long serialVersionUID = -8161084528823937553L;
       private static final List VALUES = new ArrayList(6);
       public static final VerticalDatumType OTHER_SURFACE = new VerticalDatumType("OTHER_SURFACE");
       public static final VerticalDatumType GEOIDAL = new VerticalDatumType("GEOIDAL");
       public static final VerticalDatumType ELLIPSOIDAL = new VerticalDatumType("ELLIPSOIDAL");
       public static final VerticalDatumType DEPTH = new VerticalDatumType("DEPTH");
       public static final VerticalDatumType BAROMETRIC = new VerticalDatumType("BAROMETRIC");
       public static final VerticalDatumType ORTHOMETRIC = new VerticalDatumType("ORTHOMETRIC");
       public VerticalDatumType(final String name) {
        super(name, VALUES);
    }
       public static VerticalDatumType[] values() {
        synchronized (VALUES) {
            return (VerticalDatumType[]) VALUES.toArray(new VerticalDatumType[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.referencing;
import org.opengis.metadata.citation.Citation;
public interface Factory {
       Citation getVendor();
}
package org.opengis.referencing;
public class FactoryException extends Exception {
       private static final long serialVersionUID = -3414250034883898315L;
       public FactoryException() {
    }
       public FactoryException(String message) {
        super(message);
    }
       public FactoryException(Exception cause) {
        super(cause.getLocalizedMessage(), cause);
    }
       public FactoryException(String message, Throwable cause) {
        super(message);
    }
}
package org.opengis.referencing;
import java.util.Locale;
import org.opengis.metadata.citation.Citation;
public interface Identifier {
       String getCode();
       String getCodeSpace();
       String getVersion();
       Citation getAuthority();
       String getRemarks(Locale locale);
}
package org.opengis.referencing;
import java.util.Locale;
public interface Info {
       String getName(Locale locale);
       Identifier[] getIdentifiers();
       String getRemarks(Locale locale);
}
package org.opengis.referencing;
public class NoSuchAuthorityCodeException extends FactoryException {
       private static final long serialVersionUID = -1573748311981746573L;
       private final String authority;
       private final String code;
       public NoSuchAuthorityCodeException(String message, String authority, String code) {
        super(message);
        this.authority = authority;
        this.code = code;
    }
       public String getAuthority() {
        return authority;
    }
       public String getAuthorityCode() {
        return code;
    }
}
package org.opengis.referencing;
public class NoSuchClassificationException extends FactoryException {
       private static final long serialVersionUID = 6749721413001501976L;
           private final String classification;
       public NoSuchClassificationException(final String message, final String classification) {
        super(message);
        this.classification = classification;
    }
           public String getClassification() {
        return classification;
    }
}
package org.opengis.referencing.operation;
public interface ConcatenatedOperation extends CoordinateOperation {
       SingleOperation[] getOperations();
}
package org.opengis.referencing.operation;
public interface ConicProjection extends Projection {
}
package org.opengis.referencing.operation;
public interface Conversion extends Operation {
       String getOperationVersion();
}
package org.opengis.referencing.operation;
import java.util.Locale;
import org.opengis.referencing.Info;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.quality.PositionalAccuracy;
import org.opengis.metadata.extent.Extent;
public interface CoordinateOperation extends Info {
       CoordinateReferenceSystem getSourceCRS();
       CoordinateReferenceSystem getTargetCRS();
       String getOperationVersion();
       PositionalAccuracy[] getPositionalAccuracy();
       Extent getValidArea();
       String getScope(Locale locale);
           MathTransform getMathTransform();
}
package org.opengis.referencing.operation;
import org.opengis.referencing.AuthorityFactory;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.NoSuchAuthorityCodeException;
  import org.opengis.referencing.crs.CoordinateReferenceSystem;
public interface CoordinateOperationAuthorityFactory extends AuthorityFactory {
       CoordinateOperation createCoordinateOperation(String code) throws FactoryException;
       CoordinateOperation createFromCoordinateReferenceSystemCodes(String sourceCode, String targetCode) throws FactoryException;
}
package org.opengis.referencing.operation;
import org.opengis.referencing.Factory;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
public interface CoordinateOperationFactory extends Factory {
       CoordinateOperation createOperation(CoordinateReferenceSystem sourceCRS, CoordinateReferenceSystem targetCRS) throws FactoryException;
       CoordinateOperation createOperation(CoordinateReferenceSystem sourceCRS, CoordinateReferenceSystem targetCRS, OperationMethod method) throws FactoryException;
}
package org.opengis.referencing.operation;
public interface CylindricalProjection extends Projection {
}
package org.opengis.referencing.operation;
public class IncompatibleOperationException extends Exception {
       private final String operationName;
       public IncompatibleOperationException(String message, String operationName) {
        super(message);
        this.operationName = operationName;
    }
       public String getOperationName() {
        return operationName;
    }
}
package org.opengis.referencing.operation;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.MismatchedDimensionException;
public interface MathTransform {
       int getDimSource();
           int getDimTarget();
           DirectPosition transform(DirectPosition ptSrc, DirectPosition ptDst)            throws MismatchedDimensionException, TransformException;
           void transform(double[] srcPts, int srcOff,                   double[] dstPts, int dstOff,                   int numPts) throws TransformException;
           void transform(float[] srcPts, int srcOff,                   float[] dstPts, int dstOff,                   int numPts) throws TransformException;
       Matrix derivative(final DirectPosition point)            throws MismatchedDimensionException, TransformException;
           MathTransform inverse() throws NoninvertibleTransformException;
           boolean isIdentity();
}
package org.opengis.referencing.operation;
public interface MathTransform1D extends MathTransform {
       double transform(final double value) throws TransformException;
           double derivative(final double value) throws TransformException;
}
package org.opengis.referencing.operation;
import java.awt.Shape;
import java.awt.geom.Point2D;
public interface MathTransform2D extends MathTransform {
       Point2D transform(final Point2D ptSrc, final Point2D ptDst) throws TransformException;
       Shape createTransformedShape(final Shape shape) throws TransformException;
       Matrix derivative(final Point2D point) throws TransformException;
}
package org.opengis.referencing.operation;
import org.opengis.referencing.Factory;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.NoSuchClassificationException;
import org.opengis.parameter.GeneralParameterValue;
public interface MathTransformFactory extends Factory {
       MathTransform createAffineTransform(Matrix matrix) throws FactoryException;
       MathTransform createConcatenatedTransform(MathTransform transform1, MathTransform transform2) throws FactoryException;
       MathTransform createPassThroughTransform(int firstAffectedOrdinate, MathTransform subTransform, int numTrailingOrdinates) throws FactoryException;
       MathTransform createParameterizedTransform(String classification, GeneralParameterValue[] parameters) throws FactoryException;
       GeneralParameterValue[] getDefaultParameters(String classification) throws NoSuchClassificationException;
       MathTransform createFromXML(String xml) throws FactoryException;
       MathTransform createFromWKT(String wkt) throws FactoryException;
}
package org.opengis.referencing.operation;
import org.opengis.util.Cloneable;
public interface Matrix extends Cloneable {
       int getNumRow();
           int getNumCol();
           double getElement(int row, int column);
           void setElement(int row, int column, double value);
           boolean isIdentity();
       Object clone();
}
package org.opengis.referencing.operation;
public class NoninvertibleTransformException extends TransformException {
       private static final long serialVersionUID = 9184806660368158575L;
       public NoninvertibleTransformException() {
    }
       public NoninvertibleTransformException(String message) {
        super(message);
    }
       public NoninvertibleTransformException(String message, Throwable cause) {
        super(message);
    }
}
package org.opengis.referencing.operation;
import org.opengis.parameter.GeneralParameterValue;
public interface Operation extends SingleOperation {
       OperationMethod getMethod();
       GeneralParameterValue[] getParameterValues();
}
package org.opengis.referencing.operation;
import java.util.Locale;
import org.opengis.referencing.Info;
import org.opengis.parameter.GeneralOperationParameter;
public interface OperationMethod extends Info {
       String getFormula(Locale locale);
       int getSourceDimensions();
       int getTargetDimensions();
       GeneralOperationParameter[] getParameters();
}
package org.opengis.referencing.operation;
public interface PassThroughOperation extends SingleOperation {
       Operation getOperation();
       int[] getModifiedCoordinates();
}
package org.opengis.referencing.operation;
public interface PlanarProjection extends Projection {
}
package org.opengis.referencing.operation;
import org.opengis.referencing.operation.Conversion;
public interface Projection extends Conversion {
}
package org.opengis.referencing.operation;
public interface SingleOperation extends CoordinateOperation {
}
package org.opengis.referencing.operation;
public interface Transformation extends Operation {
       String getOperationVersion();
}
package org.opengis.referencing.operation;
import org.opengis.spatialschema.geometry.DirectPosition;
  public class TransformException extends Exception {
       private static final long serialVersionUID = -8923944544398567533L;
       public TransformException() {
    }
       public TransformException(String message) {
        super(message);
    }
       public TransformException(String message, Throwable cause) {
        super(message);
    }
}
package org.opengis.referencing.quality;
import javax.units.Unit;
public interface AbsoluteExternalPositionalAccuracy extends PositionalAccuracy {
       double getResult();
       Unit getUnit();
}
package org.opengis.referencing.quality;
import javax.units.Unit;
public interface CovarianceElement {
       int getRowIndex();
       int getColumnIndex();
       double getCovariance();
       Unit getUnit();
}
package org.opengis.referencing.quality;
import javax.units.Unit;
import org.opengis.referencing.operation.Matrix;
public interface CovarianceMatrix extends Matrix, PositionalAccuracy {
       CovarianceElement[] getElements();
       Unit getUnit(int row, int column);
}
package org.opengis.referencing.quality;
public interface PositionalAccuracy {
       String getMeasureDescription();
}
package org.opengis.referencing.quality;
import javax.units.Unit;
public interface RelativeInternalPositionalAccuracy extends PositionalAccuracy {
       double getResult();
       Unit getUnit();
}
package org.opengis.referencing;
import java.util.Locale;
import org.opengis.metadata.extent.Extent;
public interface ReferenceSystem extends Info {
       Extent getValidArea();
       String getScope(Locale locale);
}
package org.opengis.referencing;
public interface SpatialReferenceSystemUsingGeographicIdentifier extends ReferenceSystem {
}
package org.opengis.spatialschema.geometry.aggregate;
import org.opengis.spatialschema.geometry.Geometry;
public interface Aggregate extends Geometry {
}
package org.opengis.spatialschema.geometry.aggregate;
public interface MultiPoint extends MultiPrimitive {
}
package org.opengis.spatialschema.geometry.aggregate;
public interface MultiPrimitive extends Aggregate {
}
package org.opengis.spatialschema.geometry;
import org.opengis.spatialschema.geometry.complex.Complex;
public interface Boundary extends Complex {
       public boolean isCycle();
}
package org.opengis.spatialschema.geometry.complex;
import java.util.Set;
import org.opengis.spatialschema.geometry.Geometry;
import org.opengis.spatialschema.geometry.primitive.Primitive;
 public interface Complex extends Geometry {
       public boolean isMaximal();
       public Complex[] getSuperComplexex();
       public Complex[] getSubComplexes();
       public Set getElements();
}
package org.opengis.spatialschema.geometry.complex;
import org.opengis.spatialschema.geometry.Boundary;
public interface ComplexBoundary extends Boundary {
}
package org.opengis.spatialschema.geometry.complex;
import java.util.List;
import org.opengis.spatialschema.geometry.primitive.Primitive;
public interface Composite extends Complex {
       public List getGenerators();
}
package org.opengis.spatialschema.geometry.complex;
import java.util.List;
import org.opengis.spatialschema.geometry.primitive.OrientableCurve;
public interface CompositeCurve extends Composite, OrientableCurve {
       public List getGenerators();
}
package org.opengis.spatialschema.geometry.complex;
import java.util.List;
import org.opengis.spatialschema.geometry.primitive.OrientableSurface;
public interface CompositeSurface extends Composite, OrientableSurface {
       public List getGenerators();
}
package org.opengis.spatialschema.geometry;
import org.opengis.util.Cloneable;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
public interface DirectPosition extends Cloneable {
       public int getDimension();
       public double[] getCoordinates();
       public double getOrdinate(int dimension) throws IndexOutOfBoundsException;
       public void setOrdinate(int dimension, double value) throws IndexOutOfBoundsException;
       public CoordinateReferenceSystem getCoordinateReferenceSystem();
   }
package org.opengis.spatialschema.geometry;
public interface Envelope {
       public DirectPosition getUpperCorner();
       public DirectPosition getLowerCorner();
}
package org.opengis.spatialschema.geometry.geometry;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.primitive.Bearing;
public interface Arc extends ArcString {
       public DirectPosition getCenter();
       public double getRadius();
       public Bearing getStartAngle();
       public Bearing getEndAngle();
}
package org.opengis.spatialschema.geometry.geometry;
public interface ArcByBulge extends ArcStringByBulge {
   }
package org.opengis.spatialschema.geometry.geometry;
import java.util.List;
import org.opengis.spatialschema.geometry.primitive.CurveInterpolation;
import org.opengis.spatialschema.geometry.primitive.CurveSegment;
public interface ArcString extends CurveSegment {
       public int getNumArc();
       public PointArray getControlPoints();
       public CurveInterpolation getInterpolation();
       public List asArcs();
}
package org.opengis.spatialschema.geometry.geometry;
import java.util.List;
import org.opengis.spatialschema.geometry.primitive.CurveInterpolation;
import org.opengis.spatialschema.geometry.primitive.CurveSegment;
public interface ArcStringByBulge extends CurveSegment {
       public double[] getBulges();
       public int getNumArc();
       public List getNormals();
       public CurveInterpolation getInterpolation();
       public ArcString asArcString();
}
package org.opengis.spatialschema.geometry.geometry;
public interface Circle extends Arc {
}
package org.opengis.spatialschema.geometry.geometry;
import org.opengis.spatialschema.geometry.primitive.CurveSegment;
public interface Conic extends CurveSegment {
}
package org.opengis.spatialschema.geometry.geometry;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface GenericCurve {
       public DirectPosition getStartPoint();
       public DirectPosition getEndPoint();
       public double[] getTangent(double s);
       public double getStartParam();
       public double getEndParam();
       public double getStartConstructiveParam();
       public double getEndConstructiveParam();
       public DirectPosition getConstructiveParam(double cp);
       public DirectPosition getParam(double s);
       public ParamForPoint getParamForPoint(DirectPosition p);
       public double length(Position point1, Position point2);
       public double length(double cparam1, double cparam2);
       public LineString asLineString(double maxSpacing, double maxOffset);
}
package org.opengis.spatialschema.geometry.geometry;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface GenericSurface {
       public double[] getUpNormal(DirectPosition point);
       public double getPerimeter();
       public double getArea();
}
package org.opengis.spatialschema.geometry.geometry;
public interface Geodesic extends GeodesicString {
}
package org.opengis.spatialschema.geometry.geometry;
import java.util.List;
import org.opengis.spatialschema.geometry.primitive.CurveInterpolation;
import org.opengis.spatialschema.geometry.primitive.CurveSegment;
public interface GeodesicString extends CurveSegment {
       public PointArray getControlPoints();
       public CurveInterpolation getInterpolation();
       public List asGeodesics();
}
package org.opengis.spatialschema.geometry.geometry;
import java.util.List;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
public interface GeometryFactory {
       public CoordinateReferenceSystem getCoordinateReferenceSystem();
       public LineSegment createLineSegment(Position startPoint, Position endPoint);
       public LineString createLineString(List points);
       public Geodesic createGeodesic(Position startPoint, Position endPoint);
       public GeodesicString createGeodesicString(List points);
       public Arc createArc(Position startPoint, Position midPoint, Position endPoint);
       public Arc createArc(Position startPoint, Position endPoint, double bulge, double[] normal);
       public ArcString createArcString(List points);
       public ArcByBulge createArcByBulge(Position startPoint, Position endPoint, double bulge, double[] normal);
       public ArcStringByBulge createArcStringByBulge(List points, double[] bulges,                                                   List normals);
}
package org.opengis.spatialschema.geometry.geometry;
public interface LineSegment extends LineString {
}
package org.opengis.spatialschema.geometry.geometry;
import java.util.List;
import org.opengis.spatialschema.geometry.primitive.CurveSegment;
public interface LineString extends CurveSegment {
       public PointArray getControlPoints();
       public List asLineSegments();
}
package org.opengis.spatialschema.geometry.geometry;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface ParamForPoint {
       public double getDistance();
       public DirectPosition getPosition();
}
package org.opengis.spatialschema.geometry.geometry;
import java.util.List;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
public interface PointArray {
       public int length();
       public int getDimension();
       public CoordinateReferenceSystem getCoordinateReferenceSystem();
       public DirectPosition get(int column) throws IndexOutOfBoundsException;
       public DirectPosition get(int column, DirectPosition dest) throws IndexOutOfBoundsException;
       public void set(int column, DirectPosition position) throws IndexOutOfBoundsException,                                                                UnsupportedOperationException;
           public DirectPosition[] toArray();
       public List positions();
}
package org.opengis.spatialschema.geometry.geometry;
import java.util.List;
import org.opengis.spatialschema.geometry.DirectPosition;
public interface PointGrid {
       public int width();
       public int height();
       public DirectPosition get(int row, int column) throws IndexOutOfBoundsException;
       public DirectPosition get(int row, int column, DirectPosition dest) throws IndexOutOfBoundsException;
       public void set(int row, int column, DirectPosition position) throws IndexOutOfBoundsException,                                                                         UnsupportedOperationException;
       public PointArray getRow(int row) throws IndexOutOfBoundsException;
       public List rows();
}
package org.opengis.spatialschema.geometry.geometry;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.primitive.Point;
public interface Position {
       public DirectPosition getDirect();
       public Point getIndirect();
}
package org.opengis.spatialschema.geometry;
import java.util.Set;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.IncompatibleOperationException;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.TransformException;
import org.opengis.spatialschema.geometry.complex.Complex;
public interface Geometry extends TransfiniteSet {
       public CoordinateReferenceSystem getCoordinateReferenceSystem();
       public Geometry getMbRegion();
       public DirectPosition getRepresentativePoint();
       public Boundary getBoundary();
       public Complex getClosure();
       public boolean isSimple();
       public boolean isCycle();
       public double getDistance(Geometry geometry);
       public int getDimension(DirectPosition point);
       public int getCoordinateDimension();
       public Set getMaximalComplex();
       public Geometry transform(CoordinateReferenceSystem newCRS) throws TransformException;
       public Geometry transform(CoordinateReferenceSystem newCRS, MathTransform transform) throws TransformException;
       public Envelope getEnvelope();
       public DirectPosition getCentroid();
       public Geometry getConvexHull();
       public Geometry getBuffer(double distance);
}
package org.opengis.spatialschema.geometry;
public class MismatchedDimensionException extends IllegalArgumentException {
       private static final long serialVersionUID = 3138484331425225155L;
       public MismatchedDimensionException() {
        super();
    }
           public MismatchedDimensionException(final String message) {
        super(message);
    }
}
package org.opengis.spatialschema.geometry.primitive;
public interface Bearing {
       public double[] getAngles();
       public double[] getDirection();
}
package org.opengis.spatialschema.geometry.primitive;
import java.util.List;
import org.opengis.spatialschema.geometry.geometry.GenericCurve;
public interface Curve extends OrientableCurve, GenericCurve {
       public List getSegments();
}
package org.opengis.spatialschema.geometry.primitive;
public interface CurveBoundary extends PrimitiveBoundary {
       public Point getStartPoint();
       public Point getEndPoint();
}
package org.opengis.spatialschema.geometry.primitive;
import java.util.List;
import java.util.ArrayList;
import org.opengis.util.CodeList;
import org.opengis.spatialschema.geometry.DirectPosition;
 public final class CurveInterpolation extends CodeList {
       private static final long serialVersionUID = 170309206092641598L;
       private static final List VALUES = new ArrayList(10);
       public static final CurveInterpolation LINEAR = new CurveInterpolation("LINEAR");
       public static final CurveInterpolation GEODESIC = new CurveInterpolation("GEODESIC");
       public static final CurveInterpolation CIRCULAR_ARC_3_POINTS = new CurveInterpolation(                                          "CIRCULAR_ARC_3_POINTS");
        public static final CurveInterpolation CIRCULAR_ARC_2_POINTS_WITH_BULGE = new CurveInterpolation(                                          "CIRCULAR_ARC_2_POINTS_WITH_BULGE");
        public static final CurveInterpolation ELLIPTICAL = new CurveInterpolation(                                          "ELLIPTICAL");
        public static final CurveInterpolation CLOTHOID = new CurveInterpolation(                                          "CLOTHOID");
       public static final CurveInterpolation CONIC = new CurveInterpolation(                                          "CONIC");
        public static final CurveInterpolation POLYNOMIAL_SPLINE = new CurveInterpolation(                                          "POLYNOMIAL_SPLINE");
        public static final CurveInterpolation CUBIC_SPLINE = new CurveInterpolation(                                          "CUBIC_SPLINE");
        public static final CurveInterpolation RATIONAL_SPLINE = new CurveInterpolation(                                          "RATIONAL_SPLINE");
        public CurveInterpolation(final String name) {
        super(name, VALUES);
    }
       public static CurveInterpolation[] values() {
        synchronized (VALUES) {
            return (CurveInterpolation[]) VALUES.toArray(new CurveInterpolation[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.spatialschema.geometry.primitive;
import org.opengis.spatialschema.geometry.geometry.GenericCurve;
import org.opengis.spatialschema.geometry.geometry.PointArray;
public interface CurveSegment extends GenericCurve {
       public Curve getCurve();
       public CurveInterpolation getInterpolation();
       public int getNumDerivativesAtStart();
       public int getNumDerivativeInterior();
       public int getNumDerivativesAtEnd();
       public PointArray getSamplePoints();
       public CurveBoundary getBoundary();
       public CurveSegment reverse();
}
package org.opengis.spatialschema.geometry.primitive;
import org.opengis.spatialschema.geometry.complex.CompositeCurve;
public interface OrientableCurve extends OrientablePrimitive {
          public CompositeCurve getComposite();
}
package org.opengis.spatialschema.geometry.primitive;
public interface OrientablePrimitive extends Primitive {
       public int getOrientation();
       public Primitive getPrimitive();
}
package org.opengis.spatialschema.geometry.primitive;
import org.opengis.spatialschema.geometry.complex.CompositeSurface;
public interface OrientableSurface extends OrientablePrimitive {
          public CompositeSurface getComposite();
}
package org.opengis.spatialschema.geometry.primitive;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.geometry.Position;
public interface Point extends Primitive {
       public DirectPosition getPosition();
          public Bearing getBearing(Position toPoint);
}
package org.opengis.spatialschema.geometry.primitive;
import java.util.Set;
import org.opengis.spatialschema.geometry.Geometry;
import org.opengis.spatialschema.geometry.Envelope;
import org.opengis.spatialschema.geometry.complex.Complex;
public interface Primitive extends Geometry {
          public Set getContainedPrimitives();
       public Set getContainingPrimitives();
       public Set getComplexes();
       public OrientablePrimitive[] getProxy();
}
package org.opengis.spatialschema.geometry.primitive;
import org.opengis.spatialschema.geometry.Boundary;
public interface PrimitiveBoundary extends Boundary {
}
package org.opengis.spatialschema.geometry.primitive;
import java.util.List;
import org.opengis.spatialschema.geometry.Envelope;
import org.opengis.spatialschema.geometry.DirectPosition;
import org.opengis.spatialschema.geometry.geometry.Position;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
public interface PrimitiveFactory {
       public CoordinateReferenceSystem getCoordinateReferenceSystem();
       public Primitive createPrimitive(Envelope envelope);
       public DirectPosition createDirectPosition(double[] coordinates);
       public Point createPoint(double[] coordinates);
       public Point createPoint(Position position);
       public Curve createCurve(List segments);
       public Surface createSurface(List surfaces);
       public Surface createSurface(SurfaceBoundary boundary);
       public Solid createSolid(SolidBoundary boundary);
}
package org.opengis.spatialschema.geometry.primitive;
import org.opengis.spatialschema.geometry.complex.CompositeCurve;
public interface Ring extends CompositeCurve {
       public boolean isSimple();
}
package org.opengis.spatialschema.geometry.primitive;
import org.opengis.spatialschema.geometry.complex.CompositeSurface;
public interface Shell extends CompositeSurface {
       public boolean isSimple();
}
package org.opengis.spatialschema.geometry.primitive;
public interface Solid extends Primitive {
          public double getArea();
       public double getVolume();
    }
package org.opengis.spatialschema.geometry.primitive;
public interface SolidBoundary extends PrimitiveBoundary {
       public Shell getExterior();
       public Shell[] getInteriors();
}
package org.opengis.spatialschema.geometry.primitive;
import java.util.List;
import org.opengis.spatialschema.geometry.geometry.GenericSurface;
public interface Surface extends OrientableSurface, GenericSurface {
       public List getPatches();
}
package org.opengis.spatialschema.geometry.primitive;
public interface SurfaceBoundary extends PrimitiveBoundary {
       public Ring getExterior();
       public Ring[] getInteriors();
}
package org.opengis.spatialschema.geometry.primitive;
import java.util.List;
import java.util.ArrayList;
import org.opengis.util.CodeList;
public final class SurfaceInterpolation extends CodeList {
       private static final long serialVersionUID = -8717227444427181227L;
       private static final List VALUES = new ArrayList(10);
       public static final SurfaceInterpolation NONE = new SurfaceInterpolation(                                            "NONE");
       public static final SurfaceInterpolation PLANAR = new SurfaceInterpolation(                                            "PLANAR");
       public static final SurfaceInterpolation SPHERICAL = new SurfaceInterpolation(                                            "SPHERICAL");
       public static final SurfaceInterpolation ELLIPTICAL = new SurfaceInterpolation(                                            "ELLIPTICAL");
       public static final SurfaceInterpolation CONIC = new SurfaceInterpolation(                                            "CONIC");
       public static final SurfaceInterpolation TIN = new SurfaceInterpolation(                                            "TIN");
       public static final SurfaceInterpolation PARAMETRIC_CURVE = new SurfaceInterpolation(                                            "PARAMETRIC_CURVE");
       public static final SurfaceInterpolation POLYNOMIAL_SPLINE = new SurfaceInterpolation(                                            "POLYNOMIAL_SPLINE");
       public static final SurfaceInterpolation RATIONAL_SPLINE = new SurfaceInterpolation(                                            "RATIONAL_SPLINE");
       public static final SurfaceInterpolation TRIANGULATED_SPLINE = new SurfaceInterpolation(                                            "TRIANGULATED_SPLINE");
       public SurfaceInterpolation(final String name) {
        super(name, VALUES);
    }
       public static SurfaceInterpolation[] values() {
        synchronized (VALUES) {
            return (SurfaceInterpolation[]) VALUES.toArray(new SurfaceInterpolation[VALUES.size()]);
        }
    }
       public CodeList[] family() {
        return values();
    }
}
package org.opengis.spatialschema.geometry.primitive;
import org.opengis.spatialschema.geometry.geometry.GenericSurface;
public interface SurfacePatch extends GenericSurface {
       public Surface getSurface();
       public SurfaceInterpolation getInterpolation();
       public int getNumDerivativesOnBoundary();
       public SurfaceBoundary getBoundary();
}
package org.opengis.spatialschema.geometry;
public interface TransfiniteSet {
       public boolean contains(TransfiniteSet pointSet);
       public boolean contains(DirectPosition point);
       public boolean intersects(TransfiniteSet pointSet);
       public boolean equals(TransfiniteSet pointSet);
       public TransfiniteSet union(TransfiniteSet pointSet);
       public TransfiniteSet intersection(TransfiniteSet pointSet);
       public TransfiniteSet difference(TransfiniteSet pointSet);
       public TransfiniteSet symmetricDifference(TransfiniteSet pointSet);
}
package org.opengis.util;
public interface Cloneable extends java.lang.Cloneable {
       public Object clone();
}
package org.opengis.util;
import java.io.InvalidObjectException;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
public abstract class CodeList implements Serializable {
       private static final long serialVersionUID = 5655809691319522885L;
       private transient final int ordinal;
       private final String name;
       protected CodeList(String name, final Collection values) {
        this.name = (name=name.trim());
        synchronized (values) {
            this.ordinal = values.size();
                        if (!values.add(this)) {
                throw new IllegalArgumentException(String.valueOf(values));
            }
        }
    }
       private static boolean contains(final Collection values, final String name) {
        for (final Iterator it=values.iterator();
 it.hasNext();
) {
            final CodeList code = (CodeList) it.next();
            if (name.equalsIgnoreCase(code.name)) {
                return true;
            }
        }
        return false;
    }
       public final int ordinal() {
        return ordinal;
    }
       public final String name() {
        return name;
    }
       public abstract CodeList[] family();
       public String toString() {
        String classname = getClass().getName();
        final int i = classname.lastIndexOf('.');
        if (i >= 0) {
            classname = classname.substring(i+1);
        }
        return classname + '[' + name + ']';
    }
       protected Object readResolve() throws ObjectStreamException {
        final CodeList[] codes = family();
        for (int i=0;
 i<codes.length;
 i++) {
                        if (name.equals(codes[i].name)) {
                return codes[i];
            }
        }
        throw new InvalidObjectException(toString());
    }
}
package org.opengis.util;
public class NoSuchEnumerationException extends Exception {
       private final int value;
           public NoSuchEnumerationException(final int value) {
        super("No enumeration exists for the value " + value);
        this.value = value;
    }
           public int getValue() {
        return value;
    }
}
package org.opengis.util;
import java.awt.Component;
import java.awt.Graphics;
import java.net.URL;
import java.util.Collection;
import javax.swing.Icon;
import javax.swing.ImageIcon;
public abstract class SimpleEnumerationType extends CodeList implements Comparable {
                   protected static Icon loadIconResource(Class a_class, String name) {
        URL iconURL = a_class.getResource(name);
        if (iconURL == null) {
            return getNullIcon();
        }
        return new ImageIcon(iconURL);
    }
       public static Icon getNullIcon() {
        return NULL_ICON;
    }
                   private final static Icon NULL_ICON = new NullIcon();
                   private String description;
       private final Icon icon;
                   protected SimpleEnumerationType(Collection values, String name, String description) {
        super(name, values);
        this.description = description;
        this.icon = getNullIcon();
    }
       protected SimpleEnumerationType(Collection values, String name, String description, Icon icon) {
        super(name, values);
        this.description = description;
        this.icon = icon;
    }
                   public String toString() {
        return name();
    }
                   public String getDescription() {
        return description;
    }
       public Icon getIcon() {
        return icon;
    }
                   public int compareTo(Object obj) {
        int rv = 0;
        if (this.getClass() != obj.getClass()) {
            throw new ClassCastException("Can't compare " +                                            this.getClass().getName() +                                            " to " +                                            obj.getClass().getName());
        }
        if (this != obj) {
            rv = this.ordinal() - ((SimpleEnumerationType)obj).ordinal();
        }
        return rv;
    }
                       private static class NullIcon implements Icon {
        public int getIconHeight() {
            return 16;
        }
        public int getIconWidth() {
            return 64;
        }
        public void paintIcon(Component c, Graphics g, int x, int y) {
        }
    }
}
