
package graph;
import java.util.ArrayList;
public class ClassNode implements GlobalValue{
int id;
String value;
double x,y;
int r;
int pac;
int background;
boolean exist;
double vx=0,vy=0;
boolean colorflag = true;
ArrayList<ClassNode> connections = new ArrayList<ClassNode>();
public ClassNode(int value,double x,double y,int pac,int background){
    this.value = String.valueOf(value);
    this.x = x;
    this.y = y;
this.r = 8;
this.pac = pac;
this.background = background;
this.exist = true;
    var idx = ~~(Math.random() * colorPalette.length);
    if (!this.background) {
      this.background = colorPalette[idx];
    }
*/}
public void connect(ClassNode node) {
this.connections.add(node);
}
    public int connect_count(){
return this.connections.size();
}
public boolean edge() {
if(this.x-this.r<=30||this.y-this.r<=30)return true;
else return false;
}
public void not_use(){
this.exist = false;
}
public void setX(double pointX){
this.x=pointX;
}
;
public void setY(double pointY){
this.y=pointY;
}
;
}
package graph;
import java.awt.Color;
import java.awt.Component;
import java.awt.event.MouseEvent;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableRowSorter;
public class ClassTable {
Vector<Vector<String>> row = new Vector<Vector<String>>();
Vector<String> column = new Vector<String>();
Vector<Integer> color = new Vector<Integer>();
    TableModel model;
    JTable table;
   public ClassTable() {
column.add("番号");
column.add("パス");
column.add("Internal数");
column.add("パッケージ");
column.add("色");
}
public void Add(int i,String pass,int internal,String pac,int color){
Vector<String> temp = new Vector<String>();
temp.add(String.valueOf(i));
temp.add(pass);
temp.add(String.valueOf(internal));
temp.add(pac);
temp.add(String.valueOf(color));
row.add(temp);
this.color.add(color);
}
public void DisplayTable(){
     model = new TableModel(row);
    table = model.Table_init(model);
    JScrollPane scrollPane = new JScrollPane(table);
TableRowSorter<TableModel> sorter = new TableRowSorter<TableModel> (new TableModel(row));
table.getTableHeader().setReorderingAllowed(false);
table.setRowSorter(sorter);
table.addMouseListener(new java.awt.event.MouseAdapter() {
public void mouseClicked(MouseEvent e) {
        int row = table.getSelectedRow();
    int col = table.getSelectedColumn();
    System.out.println("行" + row + "::" + "列" + col);
    table = model.Table_init(model);
}
}
);
DefaultTableColumnModel columnModel      = (DefaultTableColumnModel)table.getColumnModel();
    TableColumn col = null;
    col = columnModel.getColumn(0);
    col.setPreferredWidth(20);
    col = columnModel.getColumn(2);
    col.setPreferredWidth(20);
    col = columnModel.getColumn(4);
    col.setPreferredWidth(30);
    JFrame win = new JFrame();
win.setTitle("ClassTable");
win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
win.setBounds(10 , 10 , 400 , 800);
win.getContentPane().add(scrollPane);
win.show();
}
}
class TableModel extends AbstractTableModel {
  private int[] index;
  private String[] pass;
  private int[] Internal;
  private String[] pac;
  private int[] colors;
  private int colcount = 5;
  public TableModel(Vector<Vector<String>> vector){
    index =new int[vector.size()];
  pass =new String[vector.size()];
  Internal =new int[vector.size()];
  pac =new String[vector.size()];
  colors =new int[vector.size()];
    for(int i=0;
i<vector.size();
i++){
  Vector<String> vec = (Vector<String>)vector.get(i);
  System.out.println("+++"+vec);
  index[i] = Integer.valueOf((String) vec.get(0));
  pass[i] =   vec.get(1).toString();
  Internal[i] = Integer.valueOf((String)vec.get(2));
  pac[i] =  (String) vec.get(3);
  colors[i] = Integer.valueOf((String)vec.get(4));
  }
    }
  public JTable Table_init(TableModel model){
   JTable table = new JTable(model) {
    public Component prepareRenderer(TableCellRenderer tcr, int row, int column) {
    Component c = super.prepareRenderer(tcr, row, column);
    if(column==3){
    c.setForeground(Color.WHITE);
    c.setBackground(new Color(colors[(Integer)getValueAt(row,0)]));
    }
    else{
    c.setForeground(getForeground());
    c.setBackground(getBackground());
    }
    return c;
    }
    }
;
    return table;
  }
      public Class getColumnClass(int columnIndex) {
    switch(columnIndex) {
    case(0) : return Integer.class;
    case(1) : return String.class;
    case(2) : return Integer.class;
    case(3) : return String.class;
    case(4) : return Integer.class;
    }
    return null;
  }
  public String getColumnName(int column) {
    switch(column) {
    case(0) : return "番号";
    case(1) : return "パス";
    case(2) : return "Internal数";
    case(3) : return "パッケージ";
    case(4) : return "色";
    }
    return null;
  }
  public int getRowCount() {
return index.length;
}
   public int getColumnCount() {
return colcount;
}
   public Object getValueAt(int row, int column) {
    switch(column) {
    case(0) : return index[row];
    case(1) : return pass[row];
    case(2) : return Internal[row];
    case(3) : return pac[row];
    case(4) : return colors[row];
    }
    return null;
  }
}
package graph;
import java.util.ArrayList;
public class ForceDirectedGraph implements GlobalValue{
double BOUNCE;
double ATTENUATION;
double COULOMB;
ArrayList<ClassNode> classNodes;
public ForceDirectedGraph(ArrayList<ClassNode> nodes) {
classNodes = nodes;
this.BOUNCE = GlobalValue.BOUNCE;
this.ATTENUATION = GlobalValue.ATTENUATION;
this.COULOMB = GlobalValue.COULOMB;
}
public void add(ClassNode node){
    this.classNodes.add(node);
}
public void connect(int a,int b){
    this.classNodes.get(a).connect(this.classNodes.get(b));
    this.classNodes.get(b).connect(this.classNodes.get(a));
}
public void balance(int max){
    double distX, distY, fx, fy;
    for(int number=0;
number<this.classNodes.size();
number++){
        ClassNode targetNode = this.classNodes.get(number);
        fx = 0;
    fy = 0;
    for(int i=0;
i<this.classNodes.size();
i++) {
        if (targetNode == this.classNodes.get(i)                 ||!this.classNodes.get(i).exist        )continue;
distX = targetNode.x - this.classNodes.get(i).x;
distY = targetNode.y - this.classNodes.get(i).y;
double rsq = distX * distX + distY * distY;
fx += COULOMB * distX / rsq;
fy += COULOMB * distY / rsq;
      }
    for (int i=0;
i<targetNode.connections.size();
i++) {
!this.classNodes.get(i).exist)continue;
        distX = targetNode.connections.get(i).x - targetNode.x;
        distY = targetNode.connections.get(i).y - targetNode.y;
        fx += BOUNCE * distX;
        fy += BOUNCE * distY;
    }
    targetNode.vx = (targetNode.vx + fx) * ATTENUATION;
    targetNode.vy = (targetNode.vy + fy) * ATTENUATION;
    if (number != max) {
        targetNode.x += targetNode.vx;
        targetNode.y += targetNode.vy;
   }
      }
 }
public double coulomb_add(boolean bool){
 if(bool)    return (COULOMB+1);
 else if(COULOMB>1)    return (COULOMB-1);
 else return COULOMB;
 }
public double bounce_add(boolean bool){
BOUNCE *= 100;
if(bool)BOUNCE += 1;
else if(BOUNCE>1)BOUNCE -= 1;
return BOUNCE = Math.round(BOUNCE)/ 100;
}
}
package graph;
public interface GlobalValue {
int[][] colorPalettes = {
{
0xf39800,0xf2a218,0xf2ab30,0xf2b449,0xf2bd61}
,{
0xe6002d,0xe6002e,0xe62e53,0xe64565,0xe65c77}
,{
0x00b350,0x009944,0x009948,0x1f9956,0x2e995e}
,{
0x36318f,0x07008f,0x150e8f,0x302b8f,0x3d398f}
,{
0x801e6c,0x74085e,0x800d69,0x803370,0x804073}
,{
0x00e6da,0x00ccc2,0x009e96,0x109e97,0x3f9e99}
,{
0x5d310c,0x5c2900,0x5c3312,0x5c381c,0x5c3d25}
,{
0xff6666,0xf07070,0xf29696,0xf08b8b,0xf59494}
,{
0x88e02e,0x92e043,0x96db50,0xb2d63c,0xccf058}
,{
0x07194b,0x0f2257,0x12296a,0x17213e,0x0f296f}
,{
0x339933,0x38ac38,0x4fac4f,0x469546,0x42b742}
,{
0x3978f5,0x417cf4,0x6699ff,0x5d8ae2,0x2c65d6}
}
;
double BOUNCE = 0.05;
double ATTENUATION = 0.8;
double COULOMB = 40;
}
package graph;
import java.awt.BasicStroke;
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Rectangle;
import java.util.ArrayList;
public class GraphCanvas extends Canvas{
Image img;
Graphics graphics;
ArrayList<ForceDirectedGraph> elements = new ArrayList<ForceDirectedGraph>();
public Object balance;
 int click_focus=0;
public GraphCanvas() {
}
public void add(ForceDirectedGraph element){
this.elements.add(element);
}
public void paint(Graphics g){
graphics = g;
clear();
    for (int element=0;
element<this.elements.size();
element++) {
    NODE_CONNECT(element);
    NODE_FOCUS(element);
        }
}
public void clustering_draw(){
int rgb_str;
for (int k = 0;
 k < Cnodes.length;
 k++) {
if(!Cnodes[k].init){
if(Cnodes[k].num<max_num*1/4)rgb_str=0xCCCCCC;
else if(Cnodes[k].num<max_num*2/4)rgb_str=0x999999;
else if(Cnodes[k].num<max_num*3/4)rgb_str=0x666666;
else if(Cnodes[k].num<max_num*4/4)rgb_str=0x333333;
else rgb_str = 0xFF6666;
this.circle(Cnodes[k].x, Cnodes[k].y, Cnodes[k].r,rgb_str);
this.text(Cnodes[k].value, Cnodes[k].x, Cnodes[k].y);
}
}
}
private void NODE_CONNECT(int element){
boolean[][] connected = new boolean[elements.get(element).classNodes.size()][elements.get(element).classNodes.size()];
for (int i=0;
i<elements.get(element).classNodes.size();
i++)for (int j=0;
j<elements.get(element).classNodes.size();
j++){
connected[i][j] = false;
}
for (int i=0;
i<elements.get(element).classNodes.size();
i++){
ClassNode node = elements.get(element).classNodes.get(i);
for (int j=0;
j<node.connections.size();
j++){
if (connected[i][j] || connected[j][i])continue;
connected[i][j] = true;
connected[j][i] = true;
line(node.x, node.y, node.connections.get(j).x, node.connections.get(j).y,0xCCCCCC);
}
}
}
private void NODE_FOCUS(int element){
for (int i=0;
i<elements.get(element).classNodes.size();
i++){
ClassNode node = elements.get(element).classNodes.get(i);
for (int j=0;
j<elements.get(element).classNodes.size();
 j++){
}
}
for (int i=0;
i<elements.get(element).classNodes.size();
i++){
ClassNode node = elements.get(element).classNodes.get(i);
if(i==click_focus)circle(node.x, node.y, node.r+3, 0xFF0000);
if(node.colorflag){
circle(node.x, node.y, node.r, node.background);
}
else{
circle(node.x, node.y, node.r, 0xCCCCCC);
}
text(node.value,node.x,node.y,0xFF0000);
}
}
private void DRAWPOINT(){
}
private void drawaxis() {
}
private void circle(double x,double y,int r,int bg){
graphics.setColor(new Color(bg));
graphics.fillOval((int)(x-r),(int)(y-r), r*2, r*2);
     }
private void Rect(double x1,double y1,double x2,double y2,int bg){
graphics.setColor(new Color(bg));
graphics.fillRect((int)x1, (int)y1, (int)(x2-x1), (int)(y2-y1));
}
private void line(double fromX,double fromY,double toX,double toY,int color) {
Graphics2D g = (Graphics2D)graphics;
BasicStroke wideStroke = new BasicStroke(0.5f);
g.setStroke(wideStroke);
    g.setColor(new Color(color));
    g.drawLine((int)fromX,(int)fromY,(int)toX,(int)toY);
}
private void text(String txt,double x,double y,int color) {
    Graphics2D g2 = (Graphics2D)graphics;
    Font font = new Font("Arial", Font.BOLD, 10);
    g2.setFont(font);
    g2.setColor(new Color(0xFFFFFF));
    FontMetrics fm = g2.getFontMetrics();
Rectangle rectText = fm.getStringBounds(txt,g2).getBounds();
int str_x = (int) (rectText.width/2);
        int str_y = (int) (rectText.height/2-fm.getMaxAscent());
g2.drawString(txt,(int)(x-str_x),(int)(y-str_y));
}
private void clear(){
graphics.clearRect(0,0,1000,1000);
}
}
package graph;
import graph.io.GraphIOmodel;
import java.awt.Frame;
import java.awt.Graphics;
import java.io.IOException;
import java.util.ArrayList;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
public class Inport_file extends Frame implements GlobalValue{
static String in_Path = "xml\\cl_gwjava.xml";
int count = 0;
ArrayList<String> split_str;
static int centerX=500;
static int centerY=500;
int click_focus = 0;
ArrayList<String> list_xml = new ArrayList<String>();
 ArrayList<String> node_Name = new ArrayList<String>();
ArrayList<String> node_branch = new ArrayList<String>();
String[][] usedInternal = new String[1000][];
int internal_max=0;
int max_class=0;
ArrayList<Boolean> no_used = new ArrayList<Boolean>();
ArrayList<String> classgroup = new ArrayList<String>();
ArrayList<Integer> classgroup_number = new ArrayList<Integer>();
ArrayList<Integer> classgroup_internal = new ArrayList<Integer>();
ArrayList<Integer> classgroup_color1 = new ArrayList<Integer>();
ArrayList<Integer> classgroup_color2 = new ArrayList<Integer>();
ArrayList<Integer> parent_package = new ArrayList<Integer>();
GraphCanvas springGraph = new GraphCanvas();
ForceDirectedGraph graph;
public void run(){
graph.balance(max_class);
}
 public void paint(Graphics g){
springGraph.paint(g);
}
public Inport_file(){
import_method();
divide_package();
graph_draw();
}
public void import_method(){
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder documentBuilder = null;
try {
documentBuilder = factory.newDocumentBuilder();
}
catch(ParserConfigurationException e){
e.printStackTrace();
}
Document document = null;
try {
document = documentBuilder.parse(in_Path);
}
catch(SAXException e){
e.printStackTrace();
}
catch(IOException e){
e.printStackTrace();
}
Element root = document.getDocumentElement();
System.out.println("ノード名：" +root.getNodeName());
NodeList rootChildren = root.getChildNodes();
System.out.println("子要素の数：" + rootChildren.getLength());
System.out.println("------------------");
 for(int i=0;
 i < rootChildren.getLength();
 i++) {
Node node = rootChildren.item(i);
ArrayList<String> usedInternal_temp = new ArrayList<String>();
 if (node.getNodeType() == Node.ELEMENT_NODE) {
Element element = (Element)node;
if(!(element.getNodeName()=="classes"))continue;
NodeList pChildren = node.getChildNodes();
System.out.println("子要素の数：" + pChildren.getLength());
System.out.println("------------------");
 for (int j=0;
j<pChildren.getLength();
j++) {
Node Pnode = pChildren.item(j);
NamedNodeMap pAtr = Pnode.getAttributes();
int class_num=0;
if (pAtr!=null) {
if(pAtr.getNamedItem("innerClass").getNodeValue().equals("true")){
continue;
}
list_xml.add(pAtr.getNamedItem("name").getNodeValue());
node_Name.add(pAtr.getNamedItem("name").getNodeValue());
class_num = node_Name.size()-1;
if(pAtr.getNamedItem("usesInternal")!=null){
node_branch.add(pAtr.getNamedItem("usesInternal").getNodeValue());
}
}
NodeList ppChildren = Pnode.getChildNodes();
for (int k=0;
k<ppChildren.getLength();
k++) {
Node personNode = ppChildren.item(k);
NamedNodeMap ppAtr = personNode.getAttributes();
if (ppAtr!=null) {
if(ppAtr.getNamedItem("name").getNodeValue().matches(".*\\$.*")){
continue;
}
if(ppAtr.getNamedItem("type").getNodeValue().matches("usedBy")||ppAtr.getNamedItem("type").getNodeValue().matches("usesExternal")){
continue;
}
usedInternal_temp.add(ppAtr.getNamedItem("name").getNodeValue());
}
}
usedInternal[class_num]=(String[])usedInternal_temp.toArray(new String[0]);
usedInternal_temp.clear();
}
}
}
for(int j=0;
j<usedInternal.length;
j++){
if(usedInternal[j]==null)continue;
}
System.out.println("------------------");
for(int i=0;
i<list_xml.size();
i++){
}
System.out.println("------------------");
for(int i=0;
i<node_Name.size();
i++){
}
System.out.println("------------------");
for(int i=0;
i<node_branch.size();
i++){
}
for(int i=0;
i<node_branch.size();
i++)    if(internal_max < Integer.parseInt(node_branch.get(i))){
        internal_max = Integer.parseInt(node_branch.get(i));
        max_class = i;
    }
for(int i=0;
i<node_Name.size();
i++)no_used.add(true);
for(int i=0;
i<node_Name.size();
i++){
  for(int k=i;
k<node_Name.size();
k++){
    String connect = node_Name.get(k);
    int key = node_Name.indexOf(connect);
    no_used.set(i,false);
no_used.set(key,false);
  }
}
}
public void divide_package(){
for(int i =0;
i < node_Name.size();
i++){
    String temp = "";
    String[] str_group = node_Name.get(i).split("\\.",0);
    for(int j=0;
j<str_group.length-1;
j++){
    temp = temp+"."+str_group[j];
    }
    boolean group_flag = false;
             for(int j=0;
j<classgroup.size();
j++){
        if(temp.equals(classgroup.get(j))){
            classgroup_number.add(i,j);
            group_flag = true;
         }
    }
        if(!group_flag){
         classgroup.add(temp);
         classgroup_number.add(classgroup.size()-1);
    }
}
for(int i=0;
i<classgroup.size();
i++){
    int stl_len = 0;
    String str1 = classgroup.get(i).replaceAll("\\.","Dooooooooott");
    classgroup_internal.add(0);
    for(int j=0;
j<classgroup.size();
j++){
        String str2 = classgroup.get(j).replaceAll("\\.","Dooooooooott");
        str2 += "Dooooooooott";
        if(str1.indexOf(str2)!=-1){
            if(classgroup.get(j).length()>stl_len){
                classgroup_internal.set(i,j);
                stl_len = classgroup.get(j).length();
            }
        }
    }
}
int max_pac = 0;
 $count_num = array();
for($i =0;
$i < count($classgroup_internal);
$i++){
    $count_num[$classgroup_internal[$i]]++;
}
$max_pac = 0;
 for($i =0;
$i < count($count_num);
$i++){
    if($count_num[$max_pac]<$count_num[$i]){
            }
}
*/int color_num = 0;
int package_num = 0;
for(int i=0;
i<classgroup_internal.size();
i++){
    if(classgroup_internal.get(i)== max_pac){
        classgroup_color1.add(color_num);
        classgroup_color2.add(0);
        color_num++;
        if(color_num>=12)color_num=0;
        parent_package.add(package_num);
        package_num++;
    }
    else{
    classgroup_color1.add(0);
        classgroup_color2.add(0);
        parent_package.add(0);
    }
}
for(int i=0;
i<classgroup_internal.size();
i++){
    if(classgroup_internal.get(i)!=max_pac){
        classgroup_color1.add(i,classgroup_color1.get(classgroup_internal.get(i)));
        classgroup_color2.add(i,classgroup_color2.get(classgroup_internal.get(i))+1);
        parent_package.set(i,parent_package.get(classgroup_internal.get(i)));
    }
}
}
public void graph_draw() {
ArrayList<ClassNode> nodes = new ArrayList<ClassNode>();
for(int i=0;
i<node_Name.size();
i++){
int temp_color = colorPalettes[classgroup_color1.get(classgroup_number.get(i))][classgroup_color2.get(classgroup_number.get(i))];
if(i==max_class){
nodes.add(new ClassNode(i,centerX,centerY,classgroup_number.get(i),temp_color));
}
else{
System.out.print(classgroup_color1.get(classgroup_number.get(i))+"::");
System.out.println(classgroup_color2.get(classgroup_number.get(i)));
nodes.add(new ClassNode(i,centerX-250+(int)(Math.random()*500),centerY-250+(int)(Math.random()*500),classgroup_number.get(i),temp_color));
}
}
for(int i=0;
i<nodes.size();
i++){
if(no_used.get(i))nodes.get(i).not_use();
}
graph = new ForceDirectedGraph(nodes);
for(int j=0;
j<usedInternal.length;
j++){
if(usedInternal[j]==null)continue;
int key;
for(int k=0;
k<usedInternal[j].length;
k++){
key = node_Name.indexOf(usedInternal[j][k]);
graph.connect(j,key);
}
}
springGraph.add(graph);
}
public ClassTable get_ClassTable(){
ClassTable classTable = new ClassTable();
for(int i=0;
i<list_xml.size();
i++){
int temp_color = colorPalettes[classgroup_color1.get(classgroup_number.get(i))][classgroup_color2.get(classgroup_number.get(i))];
String[] str = list_xml.get(i).split("(\\.)");
classTable.Add(i,str[str.length-1],Integer.valueOf(node_branch.get(i)),classgroup.get(classgroup_number.get(i)),temp_color);
}
return classTable;
}
public GraphIOmodel get_GraphIOmodel(){
GraphIOmodel graphIOmodel = new GraphIOmodel();
for(int i=0;
i<list_xml.size();
i++){
int temp_color = colorPalettes[classgroup_color1.get(classgroup_number.get(i))][classgroup_color2.get(classgroup_number.get(i))];
String[] str = list_xml.get(i).split("(\\.)");
graphIOmodel.add(str[str.length-1],Integer.valueOf(node_branch.get(i)),classgroup.get(classgroup_number.get(i)),temp_color);
}
return graphIOmodel;
}
 }
package graph.io;
import graph.SpringAnim;
public class graphIO {
public SpringAnim springAnim =new SpringAnim();
public graphIO(){
springAnim.addMouseListener(springAnim);
springAnim.addMouseMotionListener(springAnim);
springAnim.setSize(1000,1000);
springAnim.setVisible(true);
    springAnim.addWindowListener(springAnim.new Adapter());
springAnim.init();
springAnim.setTitle("SpringGraph");
}
public SpringAnim get_springanim(){
return springAnim;
}
}
package graph.io;
import java.util.Vector;
public class GraphIOmodel {
public Vector<String> name = new Vector<String>();
public Vector<Integer> internal = new Vector<Integer>();
public Vector<String> packagePath = new Vector<String>();
public Vector<Integer> colorHex = new Vector<Integer>();
public void add(String name,int internal,String pac,int color) {
this.name.add(name);
this.internal.add(internal);
this.packagePath.add(pac);
this.colorHex.add(color);
}
public int length(){
return this.name.size();
}
}
package graph;
public class main {
public static void main(String[] args) {
SpringAnim springAnim =new SpringAnim();
springAnim.addMouseListener(springAnim);
springAnim.addMouseMotionListener(springAnim);
springAnim.setSize(1000,1000);
springAnim.setVisible(true);
    springAnim.addWindowListener(springAnim.new Adapter());
springAnim.init();
springAnim.setTitle("SpringGraph");
ClassTable classTable = springAnim.get_inport_file().get_ClassTable();
System.out.print(classTable);
classTable.DisplayTable();
while(true)springAnim.repaint();
}
}
package graph;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.ArrayList;
public class SpringAnim extends Frame implements Runnable,MouseListener,MouseMotionListener{
Dimension dimension;
Graphics OSG;
Image OSI;
Thread th = null;
int delay = 200;
Inport_file inport_file = new Inport_file();
static int click_x,click_y;
static boolean click_act = false;
public void init() {
dimension = getSize();
OSI = createImage(dimension.width,dimension.height);
OSG = OSI.getGraphics();
}
public void paint(Graphics g) {
OSG.clearRect(0,0,getSize().width,getSize().height);
 inport_file.run();
inport_file.paint(OSG);
g.drawImage(OSI,0,0,this);
}
public void update(Graphics g) {
paint(g);
}
public void start() {
th = new Thread(this);
th.start();
}
public void stop() {
th = null;
}
public void run() {
Thread me = Thread.currentThread();
while (th == me) {
try{
Thread.sleep(delay);
}
catch (InterruptedException e) {
}
repaint();
}
}
public class Adapter extends WindowAdapter{
    public void windowClosing(WindowEvent close){
    System.exit(0);
   }
}
public void mouseClicked(MouseEvent e) {
}
public void mousePressed(MouseEvent e) {
click_x=e.getX();
click_y=e.getY();
ArrayList<ClassNode> nodes = inport_file.graph.classNodes;
for(int i=0;
i<nodes.size();
i++){
if( calcDistance(nodes.get(i).x,nodes.get(i).y,click_x,click_y)<10){
inport_file.springGraph.click_focus = i;
}
}
System.out.print(inport_file.springGraph.click_focus);
}
public void mouseReleased(MouseEvent e) {
click_act = false;
}
public void mouseEntered(MouseEvent e) {
}
public void mouseExited(MouseEvent e) {
click_act = false;
}
public void mouseDragged(MouseEvent e) {
int x = click_x - e.getX();
int y = click_y - e.getY();
System.out.print("("+x+","+y+")\n");
ArrayList<ClassNode> nodes = inport_file.graph.classNodes;
for(int i=0;
i<nodes.size();
i++){
inport_file.graph.classNodes.get(i).x = nodes.get(i).x-x;
inport_file.graph.classNodes.get(i).y = nodes.get(i).y-y;
}
click_x=e.getX();
click_y=e.getY();
}
public void mouseMoved(MouseEvent e) {
}
public int calcDistance(double x1,double y1,int x2,int y2) {
double a, b, d;
a = x1 - x2;
b = y1 - y2;
d = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));
return (int)d;
}
public Inport_file get_inport_file() {
return inport_file;
}
}
import graph.ClassTable;
import graph.io.GraphIOmodel;
import graph.io.graphIO;
import search.new_class;
import search.io.SearchIOmodel;
import search.io.searchIO;
public class main {
public static void main(String[] arg) {
searchIO sUi = new searchIO();
graphIO gUi = new graphIO();
ClassTable classTable = gUi.get_springanim().get_inport_file().get_ClassTable();
classTable.DisplayTable();
GraphIOmodel graphIOmodel = gUi.get_springanim().get_inport_file().get_GraphIOmodel();
SearchIOmodel searchIOmodel = sUi.get_searchIOmodel();
TotalInfoTable totalInfoTable = new TotalInfoTable();
for(int i=0;
i<graphIOmodel.length();
i++){
for(int j=0;
j<searchIOmodel.length();
j++)if(graphIOmodel.name.get(i).equals(searchIOmodel.name.get(j)))totalInfoTable.Add(i,graphIOmodel.name.get(i),graphIOmodel.internal.get(i),graphIOmodel.packagePath.get(i),searchIOmodel.classinternal.get(j),searchIOmodel.extend.get(j),searchIOmodel.inplement.get(j),graphIOmodel.colorHex.get(i));
}
totalInfoTable.DisplayTable();
while(true)gUi.springAnim.repaint();
}
}
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
public class ReadFolder {
static String in_Path = "Z:\\Eclipse\\readFolder\\src\\";
static String out_path = "Z:\\Dropbox\\Dropbox\\GraduationWork\\ResearchResults\\out.csv";
int count = 0;
ArrayList<String> split_str;
ReadFolder(){
String_Clear();
File readfolder = new File(in_Path);
readFolder(readfolder);
}
public void readFolder( File dir ) {
File[] files = dir.listFiles();
if( files == null )return;
for( File file : files ) {
if( !file.exists() ){
continue;
}
else if( file.isDirectory() ){
readFolder( file );
}
else if( file.isFile() ){
execute( file );
}
}
}
public void execute( File file ) {
String filePath = file.getPath();
String parentDirectory = in_Path.replaceAll("\\\\","\\\\\\\\");
String AbsolutePath = filePath.replaceFirst(parentDirectory,"");
if(AbsolutePath.substring(0,1).equals("\\")){
AbsolutePath = AbsolutePath.replaceFirst("\\\\","");
}
String[] splitPath = AbsolutePath.split("\\.");
String extension = splitPath[splitPath.length-1];
String search_str="";
if(extension.equals("java")){
List<String> str_identifier = str_identifier();
for(int i=0;
i<str_identifier.size();
i++){
search_str = ".*\\s+"+str_identifier.get(i)+"\\s+[A-Za-z_][0-9A-Za-z_]*\\s*(=|;
).*";
search_obj(filePath,search_str);
}
search_object(filePath,AbsolutePath);
}
}
public ArrayList<String> split_class(String str) {
String[] return_str = str.split("(\\s)|(,)", 0);
ArrayList<String> result = new ArrayList<String>();
for(int i=0;
i<return_str.length;
i++){
if(!return_str[i].matches("(^\\s*$)|(\\{
)"))result.add(return_str[i]);
}
for(int i=0;
i<result.size();
i++){
if(!result.get(i).matches("\\w*"))return null;
}
return result;
}
public ArrayList<String> split_token(String str) {
String[] return_str = str.split("" + token_lure(), 0);
ArrayList<String> result = new ArrayList<String>();
for(int i=0;
i<return_str.length;
i++){
if(return_str[i].matches("/")&&return_str[i+1].matches("/"))break;
if(return_str[i].matches("\"")){
String temp="";
result.add("\"");
while(return_str[i].matches("\"")){
temp += return_str[i];
i++;
}
result.add(temp);
result.add("\"");
}
if(!return_str[i].matches("(^\\s*$)")){
result.add(return_str[i]);
}
}
return result;
}
public String token_lure() {
return ""+ "(\\s)"+ "|(?<=\\=)|(?=\\=)"+ "|(?<=,)|(?=,)"+ "|(?<=;
)|(?=;
)"+ "|(?<=\\{
)|(?=\\{
)"+ "|(?<=\\}
)|(?=\\}
)"+ "|(?<=\\()|(?=\\()"+ "|(?<=\\))|(?=\\))"+ "|(?<=\\[)|(?=\\[)"+ "|(?<=\\])|(?=\\])"+ "|(?<=\\+)|(?=\\+)"+ "|(?<=-)|(?=-)"+ "|(?<=\\*)|(?=\\*)"+ "|(?<=/)|(?=/)"+ "|(?<=DottttT)|(?=DottttT)"+ "|(?<=(!))|(?=(!))"+ "|(?<=\\|)|(?=\\|)";
}
public void search_main(String filePath){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
while(str != null){
str = str_encode(str);
if(str.matches("(.*\\s(void main).*)")){
System.out.print(str);
}
 str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void search_class(String filePath,String AbsolutePath){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
while(str != null){
str = str_encode(str);
if(str.matches("(^\\s*$)|(.*(\\*).*)|(.*(str = br.readLine();
continue;
}
if(str.matches("(.*\\s(class).*)|(.*\\s(interface).*)")){
if(split_class(str)==null)break;
split_str = split_class(str);
OutputFunction(split_str,++count,AbsolutePath);
}
str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void search_method(String filePath,String AbsolutePath){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
int readnum = 1;
while(str != null){
str = str_encode(str);
if(str.matches(".*\\s*[A-Za-z_][0-9A-Za-z_]*(\\()[^\\)]*(\\))\\s*(\\{
).*")){
split_str = split_token(str);
String temp_str = "";
temp_str = "";
for(int i=1;
i<split_str.size();
i++)System.out.print("["+split_str.get(i-1)+"]");
System.out.print("\n");
 for(int i=1;
i<split_str.size();
i++){
if(split_str.get(i).equals("(")&&!reserved_word(split_str.get(i-1))){
temp_str = split_str.get(i-1);
if(i==1)continue;
int j = i-2;
while(j>1){
if(split_str.get(j).equals("DottttT")){
temp_str = "." +temp_str;
if(j>1)j--;
}
else if(split_str.get(j).equals(")")){
temp_str = ")" + temp_str;
while(j>0){
j--;
if(split_str.get(j).equals("(")){
temp_str = "(" + temp_str;
break;
}
}
if(j>1)j--;
}
else{
temp_str = split_str.get(j) + temp_str;
if(split_str.get(j-1).equals("DottttT")&&j>1)j--;
else break;
}
}
String_Write(readnum+","+",definition,"+temp_str+","+str_decode(str)+"\n");
////抽出}
}
}
else if(str.matches(".*\\s*[A-Za-z_][0-9A-Za-z_]*(\\().*(\\)).*")){
split_str = split_token(str);
String temp_str = "";
temp_str = "";
for(int i=1;
i<split_str.size();
i++)System.out.print("["+split_str.get(i-1)+"]");
System.out.print("\n");
 for(int i=1;
i<split_str.size();
i++){
if(split_str.get(i).equals("(")&&!reserved_word(split_str.get(i-1))){
temp_str = split_str.get(i-1);
if(i==1)continue;
int j = i-2;
while(j>1){
if(split_str.get(j).equals("DottttT")){
temp_str = "." +temp_str;
if(j>1)j--;
}
else if(split_str.get(j).equals(")")){
temp_str = ")" + temp_str;
while(j>0){
j--;
if(split_str.get(j).equals("(")){
temp_str = "(" + temp_str;
break;
}
}
if(j>1)j--;
}
else{
temp_str = split_str.get(j) + temp_str;
if(split_str.get(j-1).equals("DottttT")&&j>1)j--;
else break;
}
}
String_Write(readnum+","+ ",call,"+temp_str+","+str+"\n");
////抽出}
}
}
str = br.readLine();
readnum++;
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void search_object(String filePath,String AbsolutePath){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
int readnum = 1;
int[] a;
List<String> str_identifier = str_identifier();
while(str != null){
str = str_encode(str);
for(int i=0;
i<str_identifier.size();
i++){
String search_str = ".*\\s+("+str_identifier.get(i)+")\\s+[A-Za-z_][0-9A-Za-z_]*\\s*(=|;
).*";
if(str.matches(search_str)){
split_str = split_token(str);
for(int j=0;
j<split_str.size();
j++)if(split_str.get(j).matches(str_identifier.get(i)))String_Write(readnum+","+split_str.get(j)+","+split_str.get(j+1)+"\n");
}
}
if(str.matches(".*\\s+[A-Za-z_][0-9A-Za-z_<>]*(\\[\\])*\\s+[A-Za-z_][0-9A-Za-z_]*(\\[\\])*\\s*(=|;
).*")){
split_str = split_token(str);
for(int i=2;
i<split_str.size();
i++)if(split_str.get(i).matches("(=|;
)"))if(split_str.get(i-2).matches("[A-Za-z_][0-9A-Za-z_<>]*")&&split_str.get(i-1).matches("[A-Za-z_][0-9A-Za-z_]*")&&!reserved_word(split_str.get(i-1))&&!reserved_word(split_str.get(i-2)))String_Write(readnum+","+split_str.get(i-2)+","+split_str.get(i-1)+"\n");
else if(split_str.get(i-1).matches("\\]")){
int k=2;
while(!split_str.get(i-k).matches("\\["))k++;
if(split_str.get(i-k-2).matches("[A-Za-z_][0-9A-Za-z_]*"))String_Write(readnum+","+split_str.get(i-k-2)+"[],"+split_str.get(i-k-1)+"\n");
}
else if(split_str.get(i-2).matches("\\]")){
int k=3;
while(!split_str.get(i-k).matches("\\["))k++;
if(split_str.get(i-k-1).matches("[A-Za-z_][0-9A-Za-z_]*"))String_Write(readnum+","+split_str.get(i-k-1)+"[],"+split_str.get(i-1)+"\n");
}
}
readnum++;
str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void search_obj(String filePath,String search_str){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
while(str != null){
str = str_encode(str);
if(str.matches(search_str)){
split_str = split_token(str);
String temp_str = "";
for(int i=0;
i<split_str.size();
i++)temp_str += str_decode(split_str.get(i))+" ";
String_Write(temp_str+"\n");
}
str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void OutputFunction(ArrayList<String> str,int num,String AbsolutePath){
int i=0;
String Modifier = "";
String ClassKind = "";
String ClassName = "";
String Stringkind = "";
if(str.get(i).equals("public")||str.get(i).equals("protected")||str.get(i).equals("private")){
Modifier += str.get(i);
i++;
}
 if(str.get(i).equals("abstract")||str.get(i).equals("final")){
Modifier += ","+str.get(i);
i++;
}
 else {
Modifier += ",";
}
if(str.get(i).equals("static")){
Modifier += ","+str.get(i);
i++;
}
 else {
Modifier += ",";
}
if(str.get(i).equals("class")){
ClassKind = "class";
i++;
ClassName += str.get(i);
i++;
}
else if(str.get(i).equals("interface")){
ClassKind = "interface";
i++;
ClassName += str.get(i);
i++;
}
if(i==str.size())System.out.println(num+","+AbsolutePath+","+Modifier+","+ClassKind+","+ClassName+","+Stringkind);
while(i<str.size()){
if(str.get(i).equals("extends"))Stringkind = "extends";
else if(str.get(i).equals("implements"))Stringkind = "implements";
else{
System.out.println(num+","+AbsolutePath+","+Modifier+","+ClassKind+","+ClassName+","+Stringkind+","+str_decode(str.get(i)));
}
i++;
}
return;
}
public String str_encode(String str){
str = str.replaceAll("\\.","DottttT");
return str;
}
public String str_decode(String str){
str = str.replaceAll("DottttT","\\.");
return str;
}
public List<String> str_identifier(){
List<String> str = new ArrayList<String>();
str.add("byte");
str.add("short");
str.add("int");
str.add("long");
str.add("float");
str.add("double");
str.add("char");
str.add("boolean");
str.add("string");
return str;
}
public List<String> reserved_word(){
List<String> str = new ArrayList<String>();
str.add("abstract");
str.add("assert");
str.add("doolean");
str.add("break");
str.add("byte");
str.add("case");
str.add("catch");
str.add("char");
str.add("class");
str.add("const");
str.add("continue");
str.add("default");
str.add("do");
str.add("double");
str.add("else");
str.add("extends");
str.add("final");
str.add("finally ");
str.add("float");
str.add("for");
str.add("goto");
str.add("if");
str.add("implements");
str.add("import");
str.add("instanceof");
str.add("int");
str.add("interface");
str.add("long");
str.add("native");
str.add("new");
str.add("package");
str.add("private");
str.add("protected");
str.add("public");
str.add("return");
str.add("short");
str.add("static");
str.add("strictfp");
str.add("super");
str.add("switch");
str.add("synchrnized");
str.add("this");
str.add("throw");
str.add("throws");
str.add("transient");
str.add("try");
str.add("void");
str.add("volatile ");
str.add("while");
return str;
}
public boolean reserved_word(String str){
List<String> list = reserved_word();
for(int i=0;
i<list.size();
i++){
if(list.get(i).equals(str))return true;
}
return false;
}
void String_Write(String str){
try {
FileWriter fw = new FileWriter(out_path, true);
PrintWriter pw = new PrintWriter(new BufferedWriter(fw));
pw.print(str);
System.out.print(str);
pw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
static void String_Clear(){
try {
FileWriter fw = new FileWriter(out_path, false);
PrintWriter pw = new PrintWriter(new BufferedWriter(fw));
pw.println("");
pw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
}
package search;
import java.awt.event.MouseEvent;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableColumn;
import javax.swing.table.TableRowSorter;
public class ClassInfoTable {
static Vector<Vector<String>> row = new Vector<Vector<String>>();
Vector<String> column = new Vector<String>();
    TableModel model;
    JTable table;
   public ClassInfoTable() {
column.add("番号");
column.add("クラス名");
column.add("class/interface");
column.add("extend");
column.add("implements");
}
public static void Add(int i,String name,String kind,String ext,String imp){
Vector<String> temp = new Vector<String>();
temp.add(String.valueOf(i));
temp.add(name);
temp.add(kind);
temp.add(ext);
temp.add(imp);
row.add(temp);
}
public void DisplayTable(){
     model = new TableModel(row);
    table = model.Table_init(model);
    JScrollPane scrollPane = new JScrollPane(table);
TableRowSorter<TableModel> sorter = new TableRowSorter<TableModel> (new TableModel(row));
table.getTableHeader().setReorderingAllowed(false);
table.setRowSorter(sorter);
table.addMouseListener(new java.awt.event.MouseAdapter() {
public void mouseClicked(MouseEvent e) {
        int row = table.getSelectedRow();
    int col = table.getSelectedColumn();
    System.out.println("行" + row + "::" + "列" + col);
    table = model.Table_init(model);
}
}
);
DefaultTableColumnModel columnModel      = (DefaultTableColumnModel)table.getColumnModel();
    TableColumn col = null;
    col = columnModel.getColumn(0);
    col.setPreferredWidth(20);
    col = columnModel.getColumn(2);
    col.setPreferredWidth(20);
    col = columnModel.getColumn(4);
    col.setPreferredWidth(30);
    JFrame win = new JFrame();
win.setTitle("ClassTable");
win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
win.setBounds(10 , 10 , 400 , 800);
win.getContentPane().add(scrollPane);
win.show();
}
}
class TableModel extends AbstractTableModel {
  private int[] index;
  private String[] name;
  private String[] kind;
  private String[] ext;
  private String[] imp;
  private int colcount = 5;
  public TableModel(Vector<Vector<String>> vector){
    index =new int[vector.size()];
  name =new String[vector.size()];
  kind =new String[vector.size()];
  ext =new String[vector.size()];
  imp =new String[vector.size()];
    for(int i=0;
i<vector.size();
i++){
  Vector<String> vec = (Vector<String>)vector.get(i);
  index[i] = Integer.valueOf((String) vec.get(0));
  name[i] =   vec.get(1).toString();
  kind[i] = (String)vec.get(2);
  ext[i] =  (String)vec.get(3);
  imp[i] = (String)vec.get(4);
  }
    }
  public JTable Table_init(TableModel model){
   JTable table = new JTable(model) {
    }
;
   return table;
  }
      public Class getColumnClass(int columnIndex) {
    switch(columnIndex) {
    case(0) : return Integer.class;
    case(1) : return String.class;
    case(2) : return String.class;
    case(3) : return String.class;
    case(4) : return String.class;
    }
    return null;
  }
  public String getColumnName(int column) {
    switch(column) {
    case(0) : return "番号";
    case(1) : return "クラス名";
    case(2) : return "class/interface";
    case(3) : return "extend";
    case(4) : return "implements";
    }
    return null;
  }
  public int getRowCount() {
return index.length;
}
   public int getColumnCount() {
return colcount;
}
   public Object getValueAt(int row, int column) {
    switch(column) {
    case(0) : return index[row];
    case(1) : return name[row];
    case(2) : return kind[row];
    case(3) : return ext[row];
    case(4) : return imp[row];
    }
    return null;
  }
}
package search;
import java.util.ArrayList;
public class class_info {
String class_name;
 String kind;
ArrayList<String> interfaceString = new ArrayList<String>();
ArrayList<String> extendString = new ArrayList<String>();
ArrayList<new_class> new_classes = new ArrayList<new_class>();
ArrayList<object_type> object_types = new ArrayList<object_type>();
ArrayList<method_type> definitionMethod = new ArrayList<method_type>();
ArrayList<String> callMethod = new ArrayList<String>();
int startLine;
public class_info(String class_name,String kind,int startLine){
this.class_name = class_name;
this.kind = kind;
this.startLine = startLine;
}
public void interface_add(String iString){
this.interfaceString.add(iString);
}
public void extend_add(String eString){
this.extendString.add(eString);
}
public void new_class_add(int id,String name,String identifer){
this.new_classes.add(new new_class(id,name,identifer));
}
public void object_types_add(String type,String identifier){
this.object_types.add(new object_type(type,identifier));
}
public void definitionMethod_add(String type,String identifier){
this.definitionMethod.add(new method_type(type,identifier));
}
public void callMethod_add(String identifier){
this.callMethod.add(identifier);
}
public String name_get(){
return class_name;
}
public String kind_get(){
return kind;
}
public String interface_get(){
String return_str = "";
for(int i=0;
i<interfaceString.size();
i++){
if(return_str != "")return_str += ",";
return_str += interfaceString.get(i);
}
return return_str;
}
public String extend_get(){
String return_str = "";
for(int i=0;
i<extendString.size();
i++){
if(return_str != "")return_str += ",";
return_str += extendString.get(i);
}
return return_str;
}
public ArrayList<new_class> new_class_get(){
return new_classes;
}
public ArrayList<method_type> definition_get(){
return definitionMethod;
}
public ArrayList<String> callmethod_get(){
return callMethod;
}
public boolean definition_search(String search){
for(int i=0;
i<definitionMethod.size();
i++)if(definitionMethod.get(i).identifier_get().equals(search))return true;
return false;
}
public int startline_get(){
return startLine;
}
}
package search;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
public class Clear_source {
static String path_str = "Z:\\Dropbox\\";
static String in_Path = "C:\\pleiades\\workspace\\GWjava\\src";
static String out_path = "result\\sourse.txt";
int count = 0;
ArrayList<String> split_str;
String temp_str="";
boolean comment_flag = false;
 boolean block_comment_flag = false;
 public Clear_source(){
String_Clear();
File readfolder = new File(in_Path);
readFolder(readfolder);
}
public void readFolder( File dir ) {
File[] files = dir.listFiles();
if( files == null )return;
for( File file : files ) {
if( !file.exists() ){
continue;
}
else if( file.isDirectory() ){
readFolder( file );
}
else if( file.isFile() ){
execute( file );
}
}
}
public void execute( File file ) {
String filePath = file.getPath();
String parentDirectory = in_Path.replaceAll("\\\\","\\\\\\\\");
String AbsolutePath = filePath.replaceFirst(parentDirectory,"");
if(AbsolutePath.substring(0,1).equals("\\")){
AbsolutePath = AbsolutePath.replaceFirst("\\\\","");
}
String[] splitPath = AbsolutePath.split("\\.");
String extension = splitPath[splitPath.length-1];
String search_str="";
if(extension.equals("java")){
System.out.println(splitPath[0]);
replace_n(filePath);
}
}
public void replace_n(String filePath){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
while(str != null){
String[] str_split = str.split( (""+ "(?<=;
)|(?<=\\{
)|(?<=\\}
)"+ "|(?<=\\s(/)(\\*))|(?=\\s(/)(\\*))"+ "|(?<=(\\*)(/))|(?=(\\*)(/))"+ "|(?<=(+ "|(?<=(@))|(?=(@))"),0);
for(int i=0;
i<str_split.length;
i++){
str_split[i] = str_split[i].replaceAll("\t","");
if(str_split[i].equals("\\s*"))break;
if(str_split[i].equals(""))break;
if(str_split[i].matches("comment_flag = true;
break;
}
if(str_split[i].matches((".*(/)(\\*).*"))){
block_comment_flag = true;
}
i++;
}
*/if(!block_comment_flag){
if(str_split[i].matches(".*;
")||str_split[i].matches(".*\\{
")||str_split[i].matches(".*\\}
")){
String_Write(str_split[i]+"\n");
}
 else {
String_Write(str_split[i]);
}
}
if(block_comment_flag && str_split[i].matches("\\*/")){
block_comment_flag = false;
}
}
comment_flag = false;
str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public String str_encode(String str){
str = str.replaceAll("\\.","DottttT");
return str;
}
public String str_decode(String str){
str = str.replaceAll("DottttT","\\.");
return str;
}
void String_Write(String str){
try {
FileWriter fw = new FileWriter(out_path, true);
PrintWriter pw = new PrintWriter(new BufferedWriter(fw));
pw.print(str);
pw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
static void String_Clear(){
try {
FileWriter fw = new FileWriter(out_path, false);
PrintWriter pw = new PrintWriter(new BufferedWriter(fw));
pw.println("");
pw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
}
package search.io;
import java.util.ArrayList;
import search.Search_sourse;
import search.class_info;
import search.new_class;
public class searchIO {
private ArrayList<class_info> class_infos;
SearchIOmodel searchIOmodel = new SearchIOmodel();
public searchIO(){
Search_sourse search_sourse = new Search_sourse();
class_infos = search_sourse.get_classinfo();
}
public ArrayList<class_info> get_classinfo(){
return class_infos;
}
public SearchIOmodel get_searchIOmodel() {
SearchIOmodel searchIOmodel = new SearchIOmodel();
for(int i=0;
i<class_infos.size();
i++)searchIOmodel.add(class_infos.get(i).name_get(),class_infos.get(i).kind_get(),class_infos.get(i).extend_get(),class_infos.get(i).interface_get());
return searchIOmodel;
}
}
package search.io;
import java.util.Vector;
public class SearchIOmodel {
public Vector<String> name = new Vector<String>();
public Vector<String> classinternal = new Vector<String>();
public Vector<String> extend = new Vector<String>();
public Vector<String> inplement = new Vector<String>();
public void add(String name,String classinternal,String extend,String inplement) {
this.name.add(name);
this.classinternal.add(classinternal);
this.extend.add(extend);
this.inplement.add(inplement);
}
public int length(){
return name.size();
}
}
package search;
import java.util.ArrayList;
public class main {
private static ArrayList<class_info> class_infos;
static ObjectInfoTable objectTable = new ObjectInfoTable();
public static void main(String[] args) {
Clear_source clear_source = new Clear_source();
Search_sourse search_sourse = new Search_sourse();
class_infos = search_sourse.get_classinfo();
for(int i=0;
i<class_infos.size();
i++){
ArrayList<method_type> temp_m = class_infos.get(i).definition_get();
for(int j=0;
j<temp_m.size();
j++){
ObjectInfoTable.Add("関数定義",temp_m.get(j).returnType_get(),temp_m.get(j).identifier_get(),class_infos.get(i).name_get());
}
ArrayList<String> temp_s = class_infos.get(i).callmethod_get();
for(int j=0;
j<temp_s.size();
j++){
int num = getNameForMethod(temp_s.get(j));
String aString = null;
if(num != -1){
aString = class_infos.get(getNameForMethod(temp_s.get(j))).name_get();
}
ObjectInfoTable.Add("関数呼出","",temp_s.get(j),aString);
}
ArrayList<new_class> temp_c = class_infos.get(i).new_class_get();
for(int j=0;
j<temp_c.size();
j++){
int num = getNameForNew(temp_c.get(j).class_name);
String aString = null;
if(num != -1){
aString = class_infos.get(getNameForNew(temp_c.get(j).class_name)).name_get();
}
ObjectInfoTable.Add("オブジェクト生成",temp_c.get(j).class_name,temp_c.get(j).identifier,aString);
}
}
objectTable.DisplayTable();
}
public static int getNameForMethod(String methodName){
for(int i=0;
i<class_infos.size();
i++){
if(class_infos.get(i).definition_search(methodName))return i;
}
return -1;
}
public static int getNameForNew(String className){
for(int i=0;
i<class_infos.size();
i++){
if(className.equals(class_infos.get(i).name_get()))return i;
}
return -1;
}
}
package search;
public class method_type {
String returnType;
String identifier;
public method_type(String type,String identifier) {
this.returnType = type;
this.identifier = identifier;
}
public String returnType_get(){
return returnType;
}
public String identifier_get(){
return identifier;
}
}
package search;
public class new_class {
int class_id;
String class_name;
String identifier;
public new_class(int id,String name,String identifier) {
this.class_id = id;
this.class_name = name;
this.identifier = identifier;
}
}
package search;
import java.awt.event.MouseEvent;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableRowSorter;
public class ObjectInfoTable {
static Vector<Vector<String>> row = new Vector<Vector<String>>();
Vector<String> column = new Vector<String>();
    ObjectTableModel model;
    JTable table;
   public ObjectInfoTable() {
column.add("種類");
column.add("返り値");
column.add("識別子");
column.add("クラス");
}
public static void Add(String kind,String returnObject,String identifier,String in_class){
Vector<String> temp = new Vector<String>();
temp.add(kind);
temp.add(returnObject);
temp.add(identifier);
temp.add(in_class);
row.add(temp);
}
public void DisplayTable(){
     model = new ObjectTableModel(row);
    table = model.Table_init(model);
    JScrollPane scrollPane = new JScrollPane(table);
TableRowSorter<ObjectTableModel> sorter = new TableRowSorter<ObjectTableModel> (new ObjectTableModel(row));
table.getTableHeader().setReorderingAllowed(false);
table.setRowSorter(sorter);
table.addMouseListener(new java.awt.event.MouseAdapter() {
public void mouseClicked(MouseEvent e) {
        int row = table.getSelectedRow();
    int col = table.getSelectedColumn();
    System.out.println("行" + row + "::" + "列" + col);
    table = model.Table_init(model);
}
}
);
DefaultTableColumnModel columnModel      = (DefaultTableColumnModel)table.getColumnModel();
JFrame win = new JFrame();
win.setTitle("ClassTable");
win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
win.setBounds(10 , 10 , 400 , 800);
win.getContentPane().add(scrollPane);
win.show();
}
}
class ObjectTableModel extends AbstractTableModel {
private String[] kind;
private String[] returnObject;
private String[] identifier;
private String[] in_class;
private int colcount = 4;
public ObjectTableModel(Vector<Vector<String>> vector){
  kind =new String[vector.size()];
returnObject =new String[vector.size()];
identifier = new String[vector.size()];
in_class = new String[vector.size()];
  for(int i=0;
i<vector.size();
i++){
Vector<String> vec = (Vector<String>)vector.get(i);
kind[i] =  (String)vec.get(0);
returnObject[i] = (String)vec.get(1);
identifier[i] = (String)vec.get(2);
in_class[i] = (String)vec.get(3);
}
  }
public JTable Table_init(ObjectTableModel model){
JTable table = new JTable(model) {
    }
;
   return table;
}
  public Class getColumnClass(int columnIndex) {
switch(columnIndex) {
case(0) : return String.class;
case(1) : return String.class;
case(2) : return String.class;
case(3) : return String.class;
}
return null;
}
public String getColumnName(int column) {
    switch(column) {
    case(0) : return "種類";
    case(1) : return "返り値";
    case(2) : return "識別子";
    case(3) : return "クラス";
    }
    return null;
  }
public int getRowCount() {
return kind.length;
}
 public int getColumnCount() {
return colcount;
}
 public Object getValueAt(int row, int column) {
    switch(column) {
    case(0) : return kind[row];
    case(1) : return returnObject[row];
    case(2) : return identifier[row];
    case(3) : return in_class[row];
    }
    return null;
  }
}
package search;
public class object_type {
String type;
String identifier;
public object_type(String type,String identifier) {
this.type = type;
this.identifier = identifier;
}
}
package search;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
public class Search_sourse {
static String path_str = "C:\\";
 static String in_Path = "result\\sourse.txt";
static String out_path = "result\\out.csv";
int count = 0;
ArrayList<String> split_str;
ArrayList<class_info> class_infos = new ArrayList<class_info>();
int readline=1;
ClassInfoTable classTable = new ClassInfoTable();
public Search_sourse() {
String_Clear();
execute();
}
public void execute() {
String filePath = in_Path;
String search_str="";
search_class(filePath);
search_method(filePath);
List<String> str_identifier = str_identifier();
for(int i=0;
i<str_identifier.size();
i++){
search_str = ".*\\s+"+str_identifier.get(i)+"\\s+[A-Za-z_][0-9A-Za-z_]*\\s*(=|;
).*";
search_obj(filePath,search_str);
}
*/search_new(filePath);
System.out.println("=====");
for(int i=0;
i<class_infos.size();
i++){
class_info temp = class_infos.get(i);
String ext_get = temp.extend_get();
String int_get = temp.interface_get();
ClassInfoTable.Add(i,temp.class_name,temp.kind,ext_get,int_get);
}
classTable.DisplayTable();
}
public ArrayList<String> split_class(String str) {
String[] return_str = str.split("(\\s)|(,)", 0);
ArrayList<String> result = new ArrayList<String>();
for(int i=0;
i<return_str.length;
i++){
if(!return_str[i].matches("(^\\s*$)|(\\{
)"))result.add(return_str[i]);
}
for(int i=0;
i<result.size();
i++){
if(!result.get(i).matches("\\w*"))return null;
}
return result;
}
public ArrayList<String> split_token(String str) {
String[] return_str = str.split("" + token_lure(), 0);
ArrayList<String> result = new ArrayList<String>();
for(int i=0;
i<return_str.length;
i++){
if(return_str[i].matches("/")&&return_str[i+1].matches("/"))break;
if(return_str[i].matches("\"")){
String temp="";
result.add("\"");
while(return_str[i].matches("\"")){
temp += return_str[i];
i++;
}
result.add(temp);
result.add("\"");
}
if(!return_str[i].matches("(^\\s*$)")){
result.add(return_str[i]);
}
}
return result;
}
public String token_lure() {
return ""+ "(\\s)"+ "|(?<=\\=)|(?=\\=)"+ "|(?<=,)|(?=,)"+ "|(?<=;
)|(?=;
)"+ "|(?<=\\{
)|(?=\\{
)"+ "|(?<=\\}
)|(?=\\}
)"+ "|(?<=\\()|(?=\\()"+ "|(?<=\\))|(?=\\))"+ "|(?<=\\+)|(?=\\+)"+ "|(?<=-)|(?=-)"+ "|(?<=\\*)|(?=\\*)"+ "|(?<=/)|(?=/)"+ "|(?<=(!))|(?=(!))"+ "|(?<=\\|)|(?=\\|)";
}
public void search_main(String filePath){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
while(str != null){
str = str_encode(str);
if(str.matches("(.*\\s(void main).*)")){
}
 str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void search_class(String filePath){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile),1024 * 1024);
String str = br.readLine();
readline=1;
while(str != null){
str = str_encode(str);
if(str.matches("(.*\\s(class)\\s.*(\\{
))|(.*\\s(interface)\\s.*)")){
if(split_class(str)!=null){
split_str = split_class(str);
OutputFunction(split_str,count++);
}
}
readline++;
str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void search_method(String filePath){
try{
BufferedReader br = new BufferedReader(new FileReader(filePath));
String str = br.readLine();
readline = 1;
while(str != null){
str = str_encode(str);
if(str.matches(".*\\s*[A-Za-z_][0-9A-Za-z_]*(\\()[^\\)]*(\\))\\s*(\\{
).*")){
split_str = split_token(str);
String temp_str = "";
String type_str = "";
for(int i=1;
i<split_str.size();
i++)System.out.print("["+str_decode(split_str.get(i-1))+"]");
System.out.print("\n");
 for(int i=1;
i<split_str.size();
i++){
if(split_str.get(i).equals("(")&&!reserved_word(split_str.get(i-1))){
temp_str = split_str.get(i-1);
type_str = split_str.get(i-2);
if(split_str.get(i-2).equals("]"))type_str = split_str.get(i-4)+split_str.get(i-3)+split_str.get(i-2);
String_Write(readline+",method,"+",definition,"+temp_str+","+str_decode(str)+"\n");
////抽出class_infos.get(returnClassNumToLine(readline)).definitionMethod_add(type_str,str_decode(temp_str));
}
}
}
else if(str.matches(".*\\s*[A-Za-z_][0-9A-Za-z_]*(\\().*(\\)).*")){
split_str = null;
split_str = split_token(str);
String temp_str = "";
temp_str = "";
for(int i=1;
i<split_str.size();
i++)System.out.print("["+str_decode(split_str.get(i-1))+"]");
System.out.print("\n");
 for(int i=1;
i<split_str.size();
i++){
if(split_str.get(i).equals("(")&&!reserved_word(split_str.get(i-1))){
if(!split_str.get(i-1).matches("[A-Za-z_][0-9A-Za-z_]*"))continue;
temp_str = split_str.get(i-1);
String_Write(readline+",method,"+ ",call,"+temp_str+","+str+"\n");
////抽出class_infos.get(returnClassNumToLine(readline)).callMethod_add(str_decode(temp_str));
}
}
}
str = br.readLine();
readline++;
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void search_object(String filePath){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
int readnum = 1;
List<String> str_identifier = str_identifier();
while(str != null){
str = str_encode(str);
for(int i=0;
i<str_identifier.size();
i++){
split_str = split_token(str);
for(int j=0;
j<split_str.size();
j++)if(split_str.get(j).matches(str_identifier.get(i)))String_Write(readnum+",object,"+split_str.get(j)+","+split_str.get(j+1)+"\n");
}
if(str.matches(".*[A-Za-z_][0-9A-Za-z_<>]*(\\[\\])*\\s+[A-Za-z_][0-9A-Za-z_]*(\\[\\])*\\s*(=|;
).*")){
split_str = split_token(str);
for(int i=2;
i<split_str.size();
i++)if(split_str.get(i).matches("(=|;
)"))if(split_str.get(i-2).matches("[A-Za-z_][0-9A-Za-z_<>]*")&&split_str.get(i-1).matches("[A-Za-z_][0-9A-Za-z_]*")&&!reserved_word(split_str.get(i-1))&&!reserved_word(split_str.get(i-2))&&!split_str.get(i-2).equals("DottttT"))String_Write(readnum+",object,"+split_str.get(i-2)+","+split_str.get(i-1)+"\n");
else if(split_str.get(i-1).matches("\\]")){
int k=2;
while(!split_str.get(i-k).matches("\\["))k++;
if(split_str.get(i-k-2).matches("[A-Za-z_][0-9A-Za-z_]*"))String_Write(readnum+",object,"+split_str.get(i-k-2)+"[],"+split_str.get(i-k-1)+"\n");
}
else if(split_str.get(i-2).matches("\\]")){
int k=3;
while(!split_str.get(i-k).matches("\\["))k++;
if(split_str.get(i-k-1).matches("[A-Za-z_][0-9A-Za-z_]*"))String_Write(readnum+",object,"+split_str.get(i-k-1)+"[],"+split_str.get(i-1)+"\n");
}
}
readnum++;
str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void search_new(String filePath){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
int readline = 1;
while(str != null){
str = str_encode(str);
if(str.matches(".*\\s*[A-Za-z_][0-9A-Za-z_]*\\s*=\\s(new)\\s[A-Za-z_][0-9A-Za-z_]*.*")){
split_str = split_token(str);
String temp_str = "";
for(int i=0;
i<split_str.size();
i++)if(split_str.get(i).equals("new")){
class_infos.get(returnClassNumToLine(readline)).new_class_add(0,split_str.get(i+1),split_str.get(i-2));
temp_str += str_decode(split_str.get(i))+" ";
String_Write(readline+",new,"+temp_str+"\n");
}
}
readline++;
str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void search_obj(String filePath,String search_str){
try{
File javaFile = new File(filePath);
BufferedReader br = new BufferedReader(new FileReader(javaFile));
String str = br.readLine();
while(str != null){
str = str_encode(str);
if(str.matches(search_str)){
split_str = split_token(str);
String temp_str = "";
for(int i=0;
i<split_str.size();
i++)temp_str += str_decode(split_str.get(i))+" ";
String_Write(temp_str+"\n");
}
str = br.readLine();
}
br.close();
}
catch(FileNotFoundException e){
System.out.println(e);
}
catch(IOException e){
System.out.println(e);
}
}
public void OutputFunction(ArrayList<String> str,int num){
int i=0;
String Modifier = "";
String ClassKind = "";
String ClassName = "";
String Stringkind = "";
if(str.get(i).equals("static")){
Modifier += ","+str.get(i);
i++;
}
 else {
Modifier += ",";
}
if(str.get(i).equals("public")||str.get(i).equals("protected")||str.get(i).equals("private")){
Modifier += str.get(i);
i++;
}
 if(str.get(i).equals("abstract")||str.get(i).equals("final")){
Modifier += ","+str.get(i);
i++;
}
 else {
Modifier += ",";
}
if(str.get(i).equals("static")){
Modifier += ","+str.get(i);
i++;
}
 else {
Modifier += ",";
}
if(str.get(i).equals("class")){
ClassKind = "class";
i++;
ClassName += str.get(i);
i++;
class_infos.add(new class_info(ClassName,ClassKind,readline));
}
else if(str.get(i).equals("interface")){
ClassKind = "interface";
i++;
ClassName += str.get(i);
i++;
class_infos.add(new class_info(ClassName,ClassKind,readline));
}
while(i<str.size()){
if(str.get(i).equals("extends"))Stringkind = "extends";
else if(str.get(i).equals("implements"))Stringkind = "implements";
else{
if(Stringkind.equals("extends"))(class_infos.get(num)).extendString.add(str_decode(str.get(i)));
else if(Stringkind.equals("implements"))(class_infos.get(num)).interfaceString.add(str_decode(str.get(i)));
}
i++;
}
return;
}
public String str_encode(String str){
str = str.replaceAll("\\.","DottttT");
return str;
}
public String str_decode(String str){
str = str.replaceAll("DottttT","\\.");
return str;
}
public List<String> str_identifier(){
List<String> str = new ArrayList<String>();
str.add("byte");
str.add("short");
str.add("int");
str.add("long");
str.add("float");
str.add("double");
str.add("char");
str.add("boolean");
str.add("string");
return str;
}
public List<String> reserved_word(){
List<String> str = new ArrayList<String>();
str.add("abstract");
str.add("assert");
str.add("doolean");
str.add("break");
str.add("byte");
str.add("case");
str.add("catch");
str.add("char");
str.add("class");
str.add("const");
str.add("continue");
str.add("default");
str.add("do");
str.add("double");
str.add("else");
str.add("extends");
str.add("final");
str.add("finally ");
str.add("float");
str.add("for");
str.add("goto");
str.add("if");
str.add("implements");
str.add("import");
str.add("instanceof");
str.add("int");
str.add("interface");
str.add("long");
str.add("native");
str.add("new");
str.add("package");
str.add("private");
str.add("protected");
str.add("public");
str.add("return");
str.add("short");
str.add("static");
str.add("strictfp");
str.add("super");
str.add("switch");
str.add("synchrnized");
str.add("this");
str.add("throw");
str.add("throws");
str.add("transient");
str.add("try");
str.add("void");
str.add("volatile ");
str.add("while");
return str;
}
public boolean reserved_word(String str){
List<String> list = reserved_word();
for(int i=0;
i<list.size();
i++){
if(list.get(i).equals(str))return true;
}
return false;
}
void String_Write(String str){
try {
FileWriter fw = new FileWriter(out_path, true);
PrintWriter pw = new PrintWriter(new BufferedWriter(fw));
pw.print(str);
pw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
static void String_Clear(){
try {
FileWriter fw = new FileWriter(out_path, false);
PrintWriter pw = new PrintWriter(new BufferedWriter(fw));
pw.println("");
pw.close();
}
 catch (IOException e) {
e.printStackTrace();
}
}
public String returnClassToLine(int line){
int ans = 0;
for(int i=0;
i<class_infos.size();
i++){
if(line>=class_infos.get(i).startline_get())ans = i;
else break;
}
return class_infos.get(ans).name_get();
}
public int returnClassNumToLine(int line){
int ans = 0;
for(int i=0;
i<class_infos.size();
i++){
if(line>=class_infos.get(i).startline_get())ans = i;
else break;
}
return ans;
}
public ArrayList<class_info> get_classinfo(){
return class_infos;
}
}
import java.awt.Color;
import java.awt.Component;
import java.awt.event.MouseEvent;
import java.util.Vector;
import javax.swing.JFrame;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableRowSorter;
public class TotalInfoTable {
static Vector<Vector<String>> row = new Vector<Vector<String>>();
Vector<String> column = new Vector<String>();
Vector<Integer> color = new Vector<Integer>();
    TableModel model;
    JTable table;
   public TotalInfoTable() {
column.add("番号");
column.add("クラス名");
column.add("Internal数");
column.add("パッケージ");
column.add("class/interface");
column.add("extend");
column.add("implements");
column.add("色");
}
public void Add(int i,String name,int internal,String pac,String kind,String ext,String imp,int color){
Vector<String> temp = new Vector<String>();
temp.add(String.valueOf(i));
temp.add(name);
temp.add(String.valueOf(internal));
temp.add(pac);
temp.add(kind);
temp.add(ext);
temp.add(imp);
temp.add(String.valueOf(color));
row.add(temp);
this.color.add(color);
}
public void DisplayTable(){
     model = new TableModel(row);
    table = model.Table_init(model);
    JScrollPane scrollPane = new JScrollPane(table);
TableRowSorter<TableModel> sorter = new TableRowSorter<TableModel> (new TableModel(row));
table.getTableHeader().setReorderingAllowed(false);
table.setRowSorter(sorter);
table.addMouseListener(new java.awt.event.MouseAdapter() {
public void mouseClicked(MouseEvent e) {
        int row = table.getSelectedRow();
    int col = table.getSelectedColumn();
    System.out.println("行" + row + "::" + "列" + col);
    table = model.Table_init(model);
}
}
);
DefaultTableColumnModel columnModel      = (DefaultTableColumnModel)table.getColumnModel();
    TableColumn col = null;
    col = columnModel.getColumn(0);
    col.setPreferredWidth(20);
    col = columnModel.getColumn(2);
    col.setPreferredWidth(20);
    col = columnModel.getColumn(4);
    col.setPreferredWidth(30);
    JFrame win = new JFrame();
win.setTitle("ClassTable");
win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
win.setBounds(10 , 10 , 400 , 800);
win.getContentPane().add(scrollPane);
win.show();
}
}
class TableModel extends AbstractTableModel {
  private int[] index;
  private String[] name;
  private int[] internal;
  private String[] pac;
  private String[] kind;
  private String[] ext;
  private String[] imp;
  private int[] colors;
  private int colcount = 8;
  public TableModel(Vector<Vector<String>> vector){
    index =new int[vector.size()];
  name =new String[vector.size()];
  internal =new int[vector.size()];
  pac =new String[vector.size()];
  kind =new String[vector.size()];
  ext =new String[vector.size()];
  imp =new String[vector.size()];
  colors =new int[vector.size()];
    for(int i=0;
i<vector.size();
i++){
  Vector<String> vec = (Vector<String>)vector.get(i);
  index[i] = Integer.valueOf((String) vec.get(0));
  name[i] =   vec.get(1).toString();
  internal[i] = Integer.valueOf((String)vec.get(2));
  pac[i] = (String)vec.get(3);
  kind[i] = (String)vec.get(4);
  ext[i] =  (String)vec.get(5);
  imp[i] = (String)vec.get(6);
  colors[i] = Integer.valueOf((String)vec.get(7));
  }
    }
  public JTable Table_init(TableModel model){
   JTable table = new JTable(model) {
    public Component prepareRenderer(TableCellRenderer tcr, int row, int column) {
    Component c = super.prepareRenderer(tcr, row, column);
    if(column==3){
    c.setForeground(Color.WHITE);
    c.setBackground(new Color(colors[(Integer)getValueAt(row,0)]));
    }
    else{
    c.setForeground(getForeground());
    c.setBackground(getBackground());
    }
    return c;
    }
    }
;
   return table;
  }
      public Class getColumnClass(int columnIndex) {
    switch(columnIndex) {
    case(0) : return Integer.class;
    case(1) : return String.class;
    case(2) : return Integer.class;
    case(3) : return String.class;
    case(4) : return String.class;
    case(5) : return String.class;
    case(6) : return String.class;
    case(7) : return Integer.class;
    }
    return null;
  }
  public String getColumnName(int column) {
    switch(column) {
    case(0) : return "番号";
    case(1) : return "クラス名";
    case(2) : return "Internal数";
    case(3) : return "パッケージ";
    case(4) : return "class/interface";
    case(5) : return "extend";
    case(6) : return "implements";
    case(7) : return "色";
    }
    return null;
  }
  public int getRowCount() {
return index.length;
}
   public int getColumnCount() {
return colcount;
}
   public Object getValueAt(int row, int column) {
    switch(column) {
    case(0) : return index[row];
    case(1) : return name[row];
    case(2) : return internal[row];
    case(3) : return pac[row];
    case(4) : return kind[row];
    case(5) : return ext[row];
    case(6) : return imp[row];
    case(7) : return colors[row];
    }
    return null;
  }
}
